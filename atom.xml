<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Aurora</title>
  
  <subtitle>Stay hungry, Stay foolish.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wplll.com/"/>
  <updated>2019-03-21T09:29:22.201Z</updated>
  <id>http://wplll.com/</id>
  
  <author>
    <name>筱鹏__</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Next个性化配置之归档页添加动画</title>
    <link href="http://wplll.com/2019/03/19/addArchivesAnimate/"/>
    <id>http://wplll.com/2019/03/19/addArchivesAnimate/</id>
    <published>2019-03-19T08:59:49.000Z</published>
    <updated>2019-03-21T09:29:22.201Z</updated>
    
    <content type="html"><![CDATA[<p class="description">博客归档页文章列表配置动画，具体效果参照 <a href="https://reuixiy.github.io/archives/" target="_blank" rel="noopener">reuixiy‘s blog</a>。 </p><a id="more"></a><p>直接进入正题。</p><p>首先，确保自己的 motion 配置是否开启：</p><figure class="highlight diff"><figcaption><span>blog/themes/next/_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Use velocity to animate everything.</span><br><span class="line">motion:</span><br><span class="line"><span class="deletion">- enable: false</span></span><br><span class="line"><span class="addition">+ enable: true</span></span><br><span class="line">  async: true</span><br></pre></td></tr></table></figure><p><a href="https://reuixiy.github.io/archives/" target="_blank" rel="noopener">reuixiy‘s blog</a> 中的动画特效是 <code>perspectiveLeftIn</code>，因此我们在 <code>motion</code> 对象的最后添加一个和上面格式一样的 <code>post_type</code>  字段，如下：</p><figure class="highlight diff"><figcaption><span>文件位置：blog/themes/next/_config.yml</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> # Use velocity to animate everything.</span><br><span class="line">motion:</span><br><span class="line">  enable: true</span><br><span class="line">  async: true</span><br><span class="line">  transition:</span><br><span class="line">    ...</span><br><span class="line">    post_block: fadeIn</span><br><span class="line">    post_header: fadeIn</span><br><span class="line">    post_body: fadeIn</span><br><span class="line">    coll_header: fadeIn</span><br><span class="line">    # Only for Pisces | Gemini.</span><br><span class="line">    sidebar: slideUpIn</span><br><span class="line"><span class="addition">+   post_type: perspectiveLeftIn</span></span><br></pre></td></tr></table></figure><div class="note warning"><p>注意：该处的 post_type 可以为其他内容，但需要与下文中修改内容相对应</p></div><p>接下来编辑文件：</p><figure class="highlight diff"><figcaption><span>文件位置：blog/themes/next/source/css/_common/components/post/post.styl</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  if hexo-config('motion.transition.post_header') &#123; .post-header &#123; opacity: 0; &#125; &#125;</span><br><span class="line">  if hexo-config('motion.transition.post_body') &#123; .post-body &#123; opacity: 0; &#125; &#125;</span><br><span class="line">  if hexo-config('motion.transition.coll_header') &#123; .collection-title &#123; opacity: 0; &#125; &#125;</span><br><span class="line"><span class="addition">+ if hexo-config('motion.transition.post_type') &#123; .post-type-normal &#123; opacity: 0; &#125; &#125;</span></span><br></pre></td></tr></table></figure><p>最后一步：</p><figure class="highlight diff"><figcaption><span>文件位置：blog/themes/next/source/js/src/motion.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  var $collHeader = $('.collection-title, .archive-year');</span><br><span class="line">  var $collHeaderTransition = CONFIG.motion.transition.coll_header;</span><br><span class="line"><span class="addition">+ var $postTypeNormal = $('.post-type-normal');</span></span><br><span class="line"><span class="addition">+ var $$postTypeNormalTransition = CONFIG.motion.transition.post_type;</span></span><br><span class="line">  ...</span><br><span class="line">  ...</span><br><span class="line">  if (CONFIG.motion.transition.coll_header) &#123;</span><br><span class="line">    $collHeader.velocity('transition.' + $collHeaderTransition, postMotionOptions);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="addition">+ if (CONFIG.motion.transition.post_type) &#123;</span></span><br><span class="line"><span class="addition">+   $postTypeNormal.velocity('transition.' + $$postTypeNormalTransition, postMotionOptions);</span></span><br><span class="line"><span class="addition">+ &#125;</span></span><br></pre></td></tr></table></figure><p>到此为止，归档页面文章列表的动画已添加完毕。此方法亦可拓展到其他列表，这里不再赘述。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;博客归档页文章列表配置动画，具体效果参照 &lt;a href=&quot;https://reuixiy.github.io/archives/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;reuixiy‘s blog&lt;/a&gt;。 &lt;/p&gt;
    
    </summary>
    
      <category term="computer" scheme="http://wplll.com/categories/computer/"/>
    
      <category term="hexo" scheme="http://wplll.com/categories/computer/hexo/"/>
    
      <category term="next" scheme="http://wplll.com/categories/computer/hexo/next/"/>
    
    
      <category term="Hexo" scheme="http://wplll.com/tags/Hexo/"/>
    
      <category term="Next" scheme="http://wplll.com/tags/Next/"/>
    
      <category term="Motion" scheme="http://wplll.com/tags/Motion/"/>
    
      <category term="动画" scheme="http://wplll.com/tags/%E5%8A%A8%E7%94%BB/"/>
    
      <category term="博客" scheme="http://wplll.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>ShareMV</title>
    <link href="http://wplll.com/2019/02/05/ShareMV/"/>
    <id>http://wplll.com/2019/02/05/ShareMV/</id>
    <published>2019-02-05T15:13:50.000Z</published>
    <updated>2019-03-13T01:21:41.000Z</updated>
    
    <content type="html"><![CDATA[<p class="description">分享mv</p><p><img src="https://" alt style="width:100%"></p><div id="dplayer0" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"preload":"preload","video":{"url":"https://qiniu.wplll.com/Counting%20Sheep.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p class=&quot;description&quot;&gt;分享mv&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://&quot; alt style=&quot;width:100%&quot;&gt;&lt;/p&gt;
&lt;div id=&quot;dplayer0&quot; class=&quot;dplayer hexo-tag-dplayer-mark&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Music And Video</title>
    <link href="http://wplll.com/2018/03/18/Music-And-Video/"/>
    <id>http://wplll.com/2018/03/18/Music-And-Video/</id>
    <published>2018-03-18T06:42:05.000Z</published>
    <updated>2019-03-21T08:53:00.994Z</updated>
    
    <content type="html"><![CDATA[<p class="description">愿有岁月可回首，且以深情共白头</p><a id="more"></a><blockquote><h2 id="Music"><a href="#Music" class="headerlink" title="Music"></a>Music</h2></blockquote>        <div id="aplayer-cQoxAjSR" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-cQoxAjSR"),            narrow: false,            autoplay: false,            showlrc: 3,            music: {              title: "Lifted",              author: "Allie X",              url: "https://qiniu.wplll.com/Allie%20X%20-%20Lifted.mp3",              pic: "https://p1.music.126.net/EZC0ed-gwIuWAzUTOb8sIQ==/19140298416382259.jpg",              lrc: "https://qiniu.wplll.com/Allie%20X%20-%20Lifted.lrc"            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><blockquote><h2 id="PlayList"><a href="#PlayList" class="headerlink" title="PlayList"></a>PlayList</h2></blockquote>        <div id="aplayer-VNnKLrAb" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;"></div>  <script>  var options = {"narrow":false,"autoplay":false,"showlrc":3,"mutex":true,"music":[{"title":"Lifted","author":"Allie X","url":"https://qiniu.wplll.com/Allie%20X%20-%20Lifted.mp3","pic":"https://p1.music.126.net/EZC0ed-gwIuWAzUTOb8sIQ==/19140298416382259.jpg","lrc":"https://qiniu.wplll.com/Allie%20X%20-%20Lifted.lrc"},{"title":"River","author":"Charlie Puth","url":"https://qiniu.wplll.com/Charlie%20Puth%20-%20River.mp3","pic":"https://p1.music.126.net/1mYNu20kFlCtj1YstuSvvw==/18531168976254862.jpg","lrc":"https://qiniu.wplll.com/Charlie%20Puth%20-%20River.lrc"}]};  options.element = document.getElementById("aplayer-VNnKLrAb");  var ap = new APlayer(options);    window.aplayers || (window.aplayers = []);  window.aplayers.push(ap);  </script><blockquote><h2 id="Video"><a href="#Video" class="headerlink" title="Video"></a>Video</h2></blockquote><div id="dplayer1" class="dplayer hexo-tag-dplayer-mark" style="margin-bottom: 20px;"></div><script>(function(){var player = new DPlayer({"container":document.getElementById("dplayer1"),"preload":"preload","video":{"url":"https://qiniu.wplll.com/Counting%20Sheep.mp4"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()</script><blockquote><h2 id="Emoji"><a href="#Emoji" class="headerlink" title="Emoji"></a>Emoji</h2></blockquote><p>🙂 </p><p>taeafdafas <img class="github-emoji" title="smile" alt="smile" src="https://github.githubassets.com/images/icons/emoji/unicode/1f604.png?v8" height="20" width="20"> 测试测试 <img class="github-emoji" title="satisfied" alt="satisfied" src="https://github.githubassets.com/images/icons/emoji/unicode/1f606.png?v8" height="20" width="20">  <img class="github-emoji" title="stuck_out_tongue_closed_eyes" alt="stuck_out_tongue_closed_eyes" src="https://github.githubassets.com/images/icons/emoji/unicode/1f61d.png?v8" height="20" width="20"> 🙂 <img class="github-emoji" title="stuck_out_tongue_closed_eyes" alt="stuck_out_tongue_closed_eyes" src="https://github.githubassets.com/images/icons/emoji/unicode/1f61d.png?v8" height="20" width="20"> <img class="github-emoji" title="grinning" alt="grinning" src="https://github.githubassets.com/images/icons/emoji/unicode/1f600.png?v8" height="20" width="20"> <img id="github-emoji" src="https://qiniu.wplll.com/%E8%A1%A8%E6%83%85.gif" height="30" width="30"></p><p><img src="https://" alt style="width:100%"></p><blockquote><h2 id="Image"><a href="#Image" class="headerlink" title="Image"></a>Image</h2></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">photo_alt</span>](<span class="link">photo_url "photo_title"</span>)</span><br><span class="line">​</span><br></pre></td></tr></table></figure><p><img src="https://qiniu.wplll.com/blogImg.png" alt="image" title="FirstImg"></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;p class=&quot;description&quot;&gt;愿有岁月可回首，且以深情共白头&lt;/p&gt;
    
    </summary>
    
      <category term="Music" scheme="http://wplll.com/categories/Music/"/>
    
    
      <category term="Music" scheme="http://wplll.com/tags/Music/"/>
    
      <category term="Video" scheme="http://wplll.com/tags/Video/"/>
    
  </entry>
  
  <entry>
    <title>数组排序</title>
    <link href="http://wplll.com/2018/03/14/SortArray/"/>
    <id>http://wplll.com/2018/03/14/SortArray/</id>
    <published>2018-03-13T17:02:28.000Z</published>
    <updated>2019-03-13T02:37:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>JS数组排序及数组去重 </p></blockquote><a id="more"></a><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><h3 id="使用Array-sort"><a href="#使用Array-sort" class="headerlink" title="使用Array.sort"></a>使用Array.sort</h3><p><strong>原理：</strong>首先，js中的sort会将排序的元素类型转化成字符串进行排序。不过它是一个高阶函数，可以接受一个函数作为参数。而我们可以通过传入内部的函数，来调整数组的升序或者降序。</p><figure class="highlight javascript"><figcaption><span>Array.sort排序</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">27</span>,<span class="number">16</span>,<span class="number">34</span>,<span class="number">8</span>,<span class="number">100</span>,<span class="number">78</span>,<span class="number">82</span>,<span class="number">19</span>,<span class="number">48</span>,<span class="number">95</span>,<span class="number">63</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr.sort());</span><br><span class="line"><span class="built_in">console</span>.log( arr.sort( <span class="function">(<span class="params">item1,item2</span>) =&gt;</span> item1- item2 ) )</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/7539882-6dec786c8eb8b402.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="上例运行结果"></p><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p><strong>思路：</strong>第一次循环，开始比较当前元素与下一个元素的大小，如果比下一个元素小或者相等，则不需要交换两个元素的值；若比下一个元素大的话，则交换两个元素的值。然后，遍历整个数组，第一次遍历完之后，相同操作遍历第二遍。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">20</span>,<span class="number">24</span>,<span class="number">2</span>,<span class="number">33</span>,<span class="number">51</span>,<span class="number">77</span>,<span class="number">18</span>,<span class="number">100</span>,<span class="number">88</span>]</span><br><span class="line"><span class="comment">//定义比较的回数</span></span><br><span class="line"><span class="keyword">const</span> time = arr.length<span class="number">-1</span>;</span><br><span class="line"><span class="comment">//外层for循环控制比较的回数</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; time; i++ )&#123;</span><br><span class="line">  <span class="comment">//内层for循环控制每一回比较的次数</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">let</span> j =  <span class="number">0</span>; j &lt; time - i; j++)&#123;</span><br><span class="line">    <span class="comment">//核心：比较，交换</span></span><br><span class="line">    <span class="keyword">if</span>( arr[j] - arr[j+<span class="number">1</span>] &gt; <span class="number">0</span> )&#123;</span><br><span class="line">      <span class="keyword">const</span> temp = arr[j];</span><br><span class="line">      arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">      arr[j+<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/7539882-d2e3ab6fb5813fde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="上例输出结果"></p><p>此方法可进行优化，增加一个标志位，如果没有进行交换，则将标志位置为false，表示排序完成。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//冒泡排序优化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//定义数组</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>,<span class="number">20</span>,<span class="number">24</span>,<span class="number">2</span>,<span class="number">33</span>,<span class="number">51</span>,<span class="number">77</span>,<span class="number">18</span>,<span class="number">100</span>,<span class="number">88</span>]</span><br><span class="line"><span class="comment">//定义比较的回数</span></span><br><span class="line"><span class="keyword">const</span> time = arr.length<span class="number">-1</span>;</span><br><span class="line"><span class="comment">//外层for循环控制比较的回数</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">let</span> i = <span class="number">0</span>; i &lt; time; i++ )&#123;</span><br><span class="line">  <span class="comment">//加入标志位</span></span><br><span class="line">   <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//内层for循环控制每一回比较的次数</span></span><br><span class="line">   <span class="keyword">for</span> ( <span class="keyword">let</span> j =  <span class="number">0</span>; j &lt; time - i; j++)&#123;</span><br><span class="line">    <span class="comment">//核心：比较，交换</span></span><br><span class="line">    <span class="keyword">if</span>( arr[j] - arr[j+<span class="number">1</span>] &gt; <span class="number">0</span> )&#123;</span><br><span class="line">      <span class="keyword">const</span> temp = arr[j];</span><br><span class="line">      arr[j] = arr[j+<span class="number">1</span>];</span><br><span class="line">      arr[j+<span class="number">1</span>] = temp; </span><br><span class="line">      flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//如果</span></span><br><span class="line">   <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">   <span class="keyword">break</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/7539882-d2e3ab6fb5813fde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="上例输出结果"></p><h3 id="快速排列"><a href="#快速排列" class="headerlink" title="快速排列"></a>快速排列</h3><p><strong>思路：</strong>首先，我们需要找到一个基数，然后将比基数小的值放在基数的左边，将比基数大的值放在基数的右边，之后进行递归那两组已经归类好的数组。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">快速排序</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">30</span>,<span class="number">32</span>,<span class="number">6</span>,<span class="number">24</span>,<span class="number">37</span>,<span class="number">32</span>, <span class="number">45</span>, <span class="number">21</span>,<span class="number">38</span>,<span class="number">23</span>, <span class="number">47</span>];</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">2<span class="keyword">if</span>(arr.length &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">22<span class="keyword">return</span> arr;</span><br><span class="line">2&#125;</span><br><span class="line">2<span class="keyword">let</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">2<span class="keyword">const</span> left = [];</span><br><span class="line">2<span class="keyword">const</span> right = [];</span><br><span class="line">2<span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">22<span class="keyword">if</span>(arr[i] &gt; temp)&#123;</span><br><span class="line">222right.push(arr[i]);</span><br><span class="line">22&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">222left.push(arr[i]);</span><br><span class="line">22&#125;</span><br><span class="line">2&#125;</span><br><span class="line">2<span class="keyword">return</span> quickSort(left).concat([temp], quickSort(right));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(quickSort(arr));</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/7539882-bc25d44bc7c0fcc9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="上例运行结果"></p><h2 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h2><h3 id="数组去重-1"><a href="#数组去重-1" class="headerlink" title="数组去重"></a>数组去重</h3><p><strong>思路：</strong>通过Array构造函数的原型Array.prototype向所有Array对象添加数组去重的方法，new一个数组，然后遍历原数组，查找每个元素在新数组中是否存在，若不存在就将该元素push进新数组，最后新数组即为所求的原数组去重结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组去重</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">4</span>,<span class="number">45</span>,<span class="number">8</span>,<span class="number">85</span>,<span class="number">4</span>,<span class="number">8</span>,<span class="number">5</span>,<span class="number">5</span>];</span><br><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">2<span class="keyword">var</span> newArr = [];</span><br><span class="line">2<span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">        <span class="comment">//若查不到arr[i]元素就向新数组中存储arr[i]</span></span><br><span class="line">22<span class="keyword">if</span>(newArr.indexOf(<span class="keyword">this</span>[i]) == <span class="number">-1</span>) &#123;</span><br><span class="line">222newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">22&#125;</span><br><span class="line">2&#125;</span><br><span class="line">2<span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(arr.unique());</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/7539882-70e43ff59ae97a15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="上例运行结果"></p><h3 id="对象键值对法"><a href="#对象键值对法" class="headerlink" title="对象键值对法"></a>对象键值对法</h3><p><strong>思路：</strong>有时我们不仅需要将数组去重，还需要显示出该数组中重复元素出现的次数，此时需要用一个对象来存储重复元素及其重复次数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对象键值对法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="string">"f"</span>, <span class="string">"f"</span>, <span class="string">"h"</span>, <span class="string">"j"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">4</span>, ];</span><br><span class="line"><span class="comment">//第二种,对象去重,统计重复次数</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="comment">//将数组中每个元素作为键存入obj对象中</span></span><br><span class="line">2<span class="keyword">var</span> item = arr[i]; <span class="comment">//第一次1</span></span><br><span class="line">2<span class="comment">//每次循环判断obj对象中是否存在键item对应的值，若不存在，将其赋值为1，若存在，将其值加1</span></span><br><span class="line">2<span class="keyword">if</span>(obj[item]) &#123; <span class="comment">//&#123;1:&#125;</span></span><br><span class="line">22obj[item]++; <span class="comment">//&#123;1:2&#125;</span></span><br><span class="line">2&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">22obj[item] = <span class="number">1</span>; <span class="comment">//&#123;1:1&#125;   </span></span><br><span class="line">2&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(obj);</span><br><span class="line"><span class="built_in">console</span>.log(obj[<span class="string">"f"</span>]);</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/7539882-a7834ac1ff2ebde4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="上例运行结果"></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;JS数组排序及数组去重 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术" scheme="http://wplll.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="JS" scheme="http://wplll.com/tags/JS/"/>
    
      <category term="技术" scheme="http://wplll.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="数组" scheme="http://wplll.com/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>JS变量对象</title>
    <link href="http://wplll.com/2017/12/21/VariableObject/"/>
    <id>http://wplll.com/2017/12/21/VariableObject/</id>
    <published>2017-12-21T13:18:51.000Z</published>
    <updated>2019-03-13T01:19:26.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本篇文章主要是对JS中的<strong>变量对象</strong>做一下总结，希望可以让看到这篇文章的各位对<strong>变量对象</strong>有更深的理解。</p></blockquote><a id="more"></a><h2 id="执行上下文的创建"><a href="#执行上下文的创建" class="headerlink" title="执行上下文的创建"></a>执行上下文的创建</h2><p>在说变量对象这个东东之前，我们需要先明白JavaScript代码的整个执行过程大概是怎么样的。JavaScript代码的整个执行过程中,分为两个阶段，先开始<strong>代码编译阶段</strong>，然后开始<strong>代码执行阶段</strong>。在<strong>代码编译阶段</strong>，编译器会将JS代码翻译成可执行代码，在这个阶段中确定了作用域规则。接下来，开始<strong>代码执行阶段</strong>，由引擎完成，这个阶段中会调用各种函数，创建执行上下文，然后执行代码。</p><hr><h2 id="变量对象出现阶段"><a href="#变量对象出现阶段" class="headerlink" title="变量对象出现阶段"></a>变量对象出现阶段</h2><p>在调用一个函数时，会有一个执行上下文被创建。该执行上下文过程的生命周期分为两个阶段：<br><strong><em>创建阶段</em></strong><br>在此阶段，执行上下文开始创建<strong>变量对象</strong>，确定作用域链，this的指向等。<br><strong><em>代码执行阶段</em></strong><br>创建阶段完成后，开始执行代码，在这个时候，才开始变量的赋值，函数的引用，以及执行其他的代码。<br><img src="http://upload-images.jianshu.io/upload_images/7539882-4369ce9c697fb523.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="变量对象于执行上下文创建阶段生成"></p><blockquote><p>简而言之，调用一个函数时，会生成一个执行上下文，这个执行上下文会先创建变量对象，确定作用域链，this指向等，然后执行上下文开始根据作用域链，先对变量对象中各变量赋值，再执行其他可执行代码。</p></blockquote><hr><h2 id="变量对象生成阶段"><a href="#变量对象生成阶段" class="headerlink" title="变量对象生成阶段"></a>变量对象生成阶段</h2><p>1、 创建一个arguments对象，即存放该函数中的所有变量的对象。<br>2、 检查该函数体中的由function关键字声明的函数，若调用函数中有由function声明的函数，则以该函数的函数名为属性名在变量对象中创建一个属性，属性值为该函数内存地址的引用。若以该函数名创建的属性已经存在，该属性值会将原来的覆盖。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//demo01</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在该例中，首先 foo 作为arguments对象属性名存入其中，此时为</span></span><br><span class="line"><span class="comment">// arguments = &#123;foo: dcab****&#125;     </span></span><br><span class="line"><span class="comment">//此处的 "dcab****" 为 "ƒ foo() &#123;return 1;&#125;" 的内存地址</span></span><br></pre></td></tr></table></figure><p>3、 检查该函数体中的由var关键字声明的变量，每检测到一个就将其变量名作为变量对象的属性名存入其中，属性值为该变量值。如果找到var声明变量，则以该变量名为属性在变量对象中创建属性，属性值为undefined。在变量对象中，若var声明的变量名已经存在，则不重复声明，跳过该var声明变量在变量对象中的属性创建。</p><p><strong>综上所述</strong>：在函数调用创建变量对象过程中，首先检查function函数声明并在变量对象中以其函数名创建属性，属性值为该函数内存地址的引用，若该属性已存在，则属性值会将原来的覆盖。然后才是检查var声明变量，并以其变量名在变量对象中创建属性，属性值为该变量值，若该属性名已存在，属性值指向的是一个函数的内存的引用，则跳过对该var声明变量在变量对象中属性的创建。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//demo02</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(foo);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> foo = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(foo);</span><br><span class="line"></span><br><span class="line">     <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line"><span class="comment">//大家可以尝试写出该实例的输出结果</span></span><br></pre></td></tr></table></figure><p>在demo02中，会有很多读者认为第一个console.log(foo)的输出结果是1或者undefined，但其实不然。按照变量对象生成顺序，首先检查实例中的function声明，并在变量对象中创建属性名为foo的属性，属性值为foo函数在内存中的引用地址。因为函数体中并没有其他的function声明，所以此时才开始检查var声明变量。首先检查到var声明的变量a，因此将 “ a : undefined, ”作为属性存入变量对象中。这里大家可能会有疑问，var a = 4 ，向变量对象中存储的属性应该是 “ a : 4， ” ，为什么会是 undefined 呢？ 需要注意的是，现在我们讨论的是变量对象的创建阶段，并不是代码执行阶段，下面有该实例的实际运行顺序（这个仅是我自己所理解的，如发现不足指出请指出，谢谢）。该实例的变量对象现在还没有创建完成，还有一个var声明的foo变量，这个时候由于变量对象中已经有了foo这个属性，因此这个var声明的foo变量就不会再作为属性存放到变量对象中，即直接跳过foo属性的创建。</p><blockquote><p>var声明的变量遇到同名属性时会跳过而不会覆盖，需要满足两个<strong>前提</strong>：<br>一、处于函数生命周期的创建对象阶段<br>二、遵循function声明优先</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//demo02实际运行顺序</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="literal">undefined</span>;</span><br><span class="line">    <span class="comment">//var foo 因为变量对象中已经存在foo属性，所以跳过该属性的创建</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(foo);     <span class="comment">//  ƒ foo() &#123;return 1;&#125;</span></span><br><span class="line">    <span class="built_in">console</span>.log(a);       <span class="comment">//  undefined</span></span><br><span class="line">    a = <span class="number">4</span>；               <span class="comment">//  执行代码阶段才会将4赋值给a</span></span><br><span class="line">    foo = <span class="number">5</span>;             <span class="comment">//   重新将5赋值给foo覆盖掉原来的函数地址引用</span></span><br><span class="line">    <span class="built_in">console</span>.log(foo);    <span class="comment">//   5 </span></span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br></pre></td></tr></table></figure><p>下面是另外一个demo:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//demo03</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(foo);</span><br><span class="line">    <span class="built_in">console</span>.log(bar);</span><br><span class="line">    <span class="keyword">var</span> foo = <span class="string">"hello"</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(foo);</span><br><span class="line">    <span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你理解透了demo2，那么demo3就不是问题，这里就不再赘述了。</p><hr><h2 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h2><p>关于变量提升，先给大家举个例子：<br>相信大家都懂function声明的函数变量与var声明的函数变量之间的区别，即function声明的变量，在声明之前调用或者在声明之后调用该函数都可以，对输出结果无影响，而var声明的函数变量，若在声明之前调用，则会返回undefined，但很多朋友都是只知其然而不知其所以然。</p><blockquote><p>其实这里的基本原理就是上述的变量对象的创建阶段，会首先检查function声明的变量，因此只要是function关键字声明的变量，位置在调用之前或者在调用之后都无所谓，因为它的优先级在创建变量对象阶段最高，当检测完了function声明的变量后，才开始检查var变量声明的变量，并且在创建阶段对var声明的变量赋值为undefined，如果var声明的变量有值，到达执行代码阶段才会将值赋给该变量。因此如果在var声明函数变量之前调用该变量，会报错undefined。</p></blockquote><p>因此，无论function关键字声明的变量与var声明的变量处于何位置，在该执行上下文的变量创建阶段中，function声明变量总是作为变量对象的属性最先被创建,接着是var声明的变量作为变量对象的属性被创建,这就是变量提升。</p><hr><h2 id="JS变量声明的优先级"><a href="#JS变量声明的优先级" class="headerlink" title="JS变量声明的优先级"></a>JS变量声明的优先级</h2><p>变量添加到作用域中的方法及优先级从高到低排序如下：</p><blockquote><ul><li>1 var声明变量并赋值</li><li>2 function声明</li><li>3 formal parameter(形参)</li><li>4 JS预定义变量</li><li>5 var声明但不赋值</li><li>6 函数的外部作用域的其他声明 </li></ul></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fnTest</span>(<span class="params">arguments</span>)</span>&#123;</span><br><span class="line">    alert(<span class="built_in">arguments</span>);<span class="comment">//function arguments()&#123;return "hello world"&#125;</span></span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">arguments</span> = <span class="number">99</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">arguments</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> <span class="string">"hello world"</span>&#125;;</span><br><span class="line">    alert(<span class="built_in">arguments</span>);<span class="comment">//99</span></span><br><span class="line">&#125;</span><br><span class="line">fnTest(<span class="number">100</span>);</span><br></pre></td></tr></table></figure><p>首先，在变量对象创建阶段，function关键字声明变量要比var声明的关键字的优先级要高，文章前面已经说明。但是在同一执行上下文中若var声明变量并赋值，最终则总会覆盖与之同名的函数声明。</p><p>对这个优先级顺序不太理解的同学可以移步去<a href="http://enml.github.io/site/2014/06/13/js-resolution/" target="_blank" rel="noopener"><strong>寂寞先生</strong></a>的博客中一探究竟。下面我们来看一个实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'world'</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">typeof</span> name === <span class="string">'undefined'</span>)&#123;</span><br><span class="line">        <span class="keyword">var</span> name = <span class="string">'Jack'</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Goodbye'</span>+name);   <span class="comment">// GoodbyeJack</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Hello'</span>+name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>这里首先要说一下沿着作用域链查找变量的方法：</p><ol><li>在局部作用域中查找（若找到则返回该变量，否则继续向下找）</li><li>在上一级的作用域中查找，（······）；</li><li>在全局作用域中查找（若找不到，则返回 typeError)</li></ol><p>此实例中，虽然在函数体外定义了全局变量name，但是函数调用过程中，会优先考虑自身作用域内的变量，而该函数内部有var声明的变量name，因此不再考虑外部全局变量name。在该函数执行上下文中，首先创建变量对象，检查到有var声明的变量，因此将“ name:undefined ”作为属性值先存储在变量对象中。在if条件判断时，name的值其实还是undefined，因为按照执行上下文的顺序,这个时候代码并没有执行到 “ name = Jack ”，所以if条件成立，执行if语句中的代码。</p><hr><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>关于变量对象，到这里大概也就介绍完毕了。在实际工作中可能很少会用到这些知识，也就面试时候可能会有一些与之有关简短的代码题，但是个人觉得理解了变量对象对学习JavaScript还是有很大帮助的，会让我们更容易接受其他的一些知识，毕竟每个知识点都不是孤立的，他们之间都有“冥冥之中”的联系~最后呢，希望大家能通过本篇文章加深对变量对象的理解，有所收获。。。</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本篇文章主要是对JS中的&lt;strong&gt;变量对象&lt;/strong&gt;做一下总结，希望可以让看到这篇文章的各位对&lt;strong&gt;变量对象&lt;/strong&gt;有更深的理解。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>VUE路由传参</title>
    <link href="http://wplll.com/2017/09/20/VueParamsTransmit/"/>
    <id>http://wplll.com/2017/09/20/VueParamsTransmit/</id>
    <published>2017-09-20T14:35:57.000Z</published>
    <updated>2019-03-13T08:09:57.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通常情况下，我们在做项目过程中会遇到vue页面路由带参跳转的情况，本文将介绍解决此问题的两种常用方案。</p></blockquote><a id="more"></a><h3 id="使用声明式导航-Router-link-跳转"><a href="#使用声明式导航-Router-link-跳转" class="headerlink" title="使用声明式导航 Router-link 跳转"></a>使用声明式导航 Router-link 跳转</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送</span></span><br><span class="line">&lt;router-link</span><br><span class="line">    :to=<span class="string">"&#123;</span></span><br><span class="line"><span class="string">        path:'selfPath',</span></span><br><span class="line"><span class="string">            params:&#123;</span></span><br><span class="line"><span class="string">                name:'name',</span></span><br><span class="line"><span class="string">                data:data</span></span><br><span class="line"><span class="string">            &#125;,</span></span><br><span class="line"><span class="string">             query:&#123;</span></span><br><span class="line"><span class="string">                name:'name',</span></span><br><span class="line"><span class="string">                data:data</span></span><br><span class="line"><span class="string">             &#125;,</span></span><br><span class="line"><span class="string">    &#125;"</span>&gt;</span><br><span class="line">&lt;<span class="regexp">/router-link&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/接收</span></span><br><span class="line"><span class="regexp">let receiveParamData = this.$route.params.data</span></span><br><span class="line"><span class="regexp">let receiveQueryData = this.$route.query.data</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">1. path-&gt; 是要跳转的路由路径，可以使路由文件里面配置的name值</span></span><br><span class="line"><span class="regexp">2. params-&gt; 是要传送的参数,直接以key:value形式传递，</span></span><br><span class="line"><span class="regexp">3. query -&gt; 是通过url来传递参数，同样以key:value形式传递</span></span><br><span class="line"><span class="regexp">注意：接收参数时，是`this.$route`而非`this.$router`！！！</span></span><br></pre></td></tr></table></figure><h3 id="使用编程式导航-Router-push-方法"><a href="#使用编程式导航-Router-push-方法" class="headerlink" title="使用编程式导航 Router.push() 方法"></a>使用编程式导航 Router.push() 方法</h3><p>在js代码中，我们可以通过使用 <code>router.push()</code> 方法来实现路由跳转，具体代码如下:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送</span></span><br><span class="line"><span class="keyword">let</span> data</span><br><span class="line"><span class="keyword">this</span>.$router.push(&#123;</span><br><span class="line">    name:<span class="string">'定义的需要跳转页面路由name值'</span>,</span><br><span class="line">    params:&#123;</span><br><span class="line">        name:<span class="string">'name'</span>,</span><br><span class="line">        data:data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.$router.push(&#123;</span><br><span class="line">    path:<span class="string">'selfPath'</span>,</span><br><span class="line">    query:&#123;</span><br><span class="line">        name:<span class="string">'name'</span>,</span><br><span class="line">        data:data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;）</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收</span></span><br><span class="line"><span class="keyword">let</span> receiveParamData = <span class="keyword">this</span>.$route.params.data</span><br><span class="line"><span class="keyword">let</span> receiveQueryData = <span class="keyword">this</span>.$route.query.data</span><br><span class="line"></span><br><span class="line">注意：如果传递参数使用的是params，那么必须使用目标页面路由的name；</span><br><span class="line">     如果传递参数使用的是query，那么必须使用目标页面路由的path。</span><br></pre></td></tr></table></figure><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>综上，声明式导航和编程式导航路由传值均可使用<code>query</code>和<code>params</code>，那么这两者有什么区别呢？呐，<code>query</code>和<code>params</code>就类似于 get 和 post ，<code>query</code>传参会将参数保存到url中，在页面刷新后传递的参数不会丢失，而<code>params</code>传参只会将参数保存在浏览器内存中，一旦刷新，浏览器释放内存，参数就丢失了。以上为个人理解，有不到位的地方还请指教~</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通常情况下，我们在做项目过程中会遇到vue页面路由带参跳转的情况，本文将介绍解决此问题的两种常用方案。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="technology" scheme="http://wplll.com/categories/technology/"/>
    
      <category term="computer" scheme="http://wplll.com/categories/technology/computer/"/>
    
      <category term="computer-aided-art" scheme="http://wplll.com/categories/technology/computer/computer-aided-art/"/>
    
    
      <category term="Vue" scheme="http://wplll.com/tags/Vue/"/>
    
      <category term="路由" scheme="http://wplll.com/tags/%E8%B7%AF%E7%94%B1/"/>
    
      <category term="传参" scheme="http://wplll.com/tags/%E4%BC%A0%E5%8F%82/"/>
    
  </entry>
  
  <entry>
    <title>《JavaScript 高级程序设计》学习笔记（一）</title>
    <link href="http://wplll.com/2017/03/20/JavaScriptBasicNotes/"/>
    <id>http://wplll.com/2017/03/20/JavaScriptBasicNotes/</id>
    <published>2017-03-20T14:35:57.000Z</published>
    <updated>2019-03-13T01:11:43.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>JavaScript 基础知识巩固 </p></blockquote><a id="more"></a><blockquote><p>第一章 JavaScript 简介 </p><p>第二章 在 HTML 中使用 JavaScript</p><p>第三章 基本概念</p><p>第四章 变量、作用域和内存</p></blockquote><h2 id="JavaScript-简介"><a href="#JavaScript-简介" class="headerlink" title="JavaScript 简介"></a>JavaScript 简介</h2><h3 id="JavaScript-简史"><a href="#JavaScript-简史" class="headerlink" title="JavaScript 简史"></a>JavaScript 简史</h3><p>JavaScript 是 1995 年 Netscape 公司开发的一种用来处理简单表单验证的客户端语言，起初命名为 LiveScript ，但为了搭上媒体热炒 Java 的顺风车，临时将 LiveScript 改名为 JavaScript 。</p><p>1996 年 8 月，微软为进入 Web 浏览器领域在 Internet Explorer 中加入了名为 JScript 的 JavaScript 实现，标志着 JavaScript 作为一门语言的开发向前迈进了一大步。</p><p>1997 年，欧洲计算机制造商协会完成了 ECMA-262 ——定义一种名为 ECMAScript 的新脚本语言的标准。</p><p>1998 年，ISO/IEC（国标标准化组织/国标电工委员会）也采用了ECMAScript 作为标准（ISO/IEC-16262）。</p><p>自此以后，各大浏览器开发商开始致力于将 ECMAScript 作为各自 JavaScript 实现的基础。</p><h3 id="JavaScript-实现"><a href="#JavaScript-实现" class="headerlink" title="JavaScript 实现"></a>JavaScript 实现</h3><p>一个完整的 JavaScript 实现应该由以下三个不同部分构成：</p><ul><li>核心（ECMAScript）</li><li>文档对象模型（DOM）</li><li>浏览器对象模型（BOM）</li></ul><h4 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h4><p>由 ECMA-262 定义的 ECMAScript 与 Web 浏览器之间没有依赖关系。本质上来讲，ECMAScript 本身并不包含输入和输出定义。ECMA-262 定义的只是这门语言的基础，在此基础之上可以构建更完善的脚本语言。常见的 Web 浏览器只是 ECMAScript 实现可能的宿主环境之一。</p><blockquote><p>宿主环境：不仅提供基本的 ECMAScript 实现，同时也会提供该语言的扩展，以便语言与环境之间对接交互。而这些扩展——如 DOM，则利用 ECMAScript 的核心类型和语法提供更多更具体的功能，以便实现针对环境的操作。其他宿主环境包括 Node 和 Adobe Flash。</p></blockquote><p>ECMA-262 虽然没有参照 Web 浏览器，但它规定了以下内容：</p><ul><li>语法</li><li>类型</li><li>语句</li><li>关键字</li><li>保留字</li><li>操作符</li><li>对象</li></ul><p>ECMAScript就是对实现该标准规定的各个方面内容的语言的描述。JavaScript 实现了 ECMAScript，Adobe ActionScript 同样实现了 ECMAScript 。</p><h4 id="文档对象模型（DOM）"><a href="#文档对象模型（DOM）" class="headerlink" title="文档对象模型（DOM）"></a>文档对象模型（DOM）</h4><p>文档对象模型（DOM）是针对 XML 但经过扩展用于 HTML 的应用程序编程接口（API）。DOM 将整个页面映射为一个多层节点结构。HTML 或 XML 页面中的每个组成部分都是某种类型的节点，这些节点又包含着不同类型的数据。</p><h5 id="DOM-级别"><a href="#DOM-级别" class="headerlink" title="DOM 级别"></a>DOM 级别</h5><p>DOM 1级由 DOM 核心（DOM Core）和 DOM HTML 组成。其中 DOM 核心规定的事如何映射基于 XML 的文档结构，以便简化对文档中任意部分的访问和操作。DOM HTML 模块则在 DOM 核心的基础上加以扩展，添加了针对 HTML 的对象和方法。</p><p>DOM 2级在原来 DOM 的基础上又扩充了（ DHTML 一直都支持的）鼠标和用户界面事件、范围、遍历（迭代 DOM 文档的方法）等细分模块，而且通过对象接口增加了对 CSS 的支持。DOM2级引入了一下新模块：</p><ul><li>DOM 视图：定义了跟踪不同文档视图（如应用 CSS 之前和之后的文档）的接口</li><li>DOM 事件：定义了事件和事件处理的接口</li><li>DOM 样式：定义了基于 CSS 为元素应用样式的接口</li><li>DOM 遍历和范围：定义了便利和操作文档树的接口</li></ul><p>DOM3 级进一步扩展了 DOM，引入了统一方式加载和保存文档的方法——在 DOM 加载和保存模块中定义；新增了验证文档的方法——在 DOM 验证模块中定义。同时 DOM 3级也对 DOM 核心进行了扩展，开始支持 XMl 1.0规范，涉及XML Infoset、XPath 和 XML Base。</p><h4 id="浏览器对象模型（BOM）"><a href="#浏览器对象模型（BOM）" class="headerlink" title="浏览器对象模型（BOM）"></a>浏览器对象模型（BOM）</h4><p>从根本上讲，BOM 只处理浏览器窗口和框架，单人们习惯上也把所有针对浏览器的 JavaScript 扩展算作 BOM 的一部分。如下：</p><ul><li>弹出新浏览器窗口的功能</li><li>移动、缩放和关闭浏览器窗口的功能</li><li>童工浏览器详细信息的 navigator 对象</li><li>提供浏览器所加载页面的详细信息的 location 对象</li><li>提供用户显示器分辨率详细信息的 screen 对象</li><li>对 cookies 的支持</li><li>像 XMLHTTPRequest 和 IE 的 ActiveXObject 这样的自定义对象</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>JavaScript 是一种专门为网页交互而设计的脚本语言，由以下三个不同部分组成：</p><ul><li>ECMAScript，由 ECMA-262 定义，提供核心语言功能</li><li>文档对象模型（DOM），提供访问和操作网页内容的方法和接口</li><li>浏览器对象模型（BOM），提供与浏览器交互的方法和接口</li></ul><p>JavaScript 的这三个组成部分，在当前五个主要浏览器（ IE、Firefox、Chriome、Safari 和 Opera ）中都得到了不同程度的支持。其中，所有浏览器对 ECMAScript 第3版的支持大体上都还不错，而对 ECMAScript5 的支持程度越来越高，但是对 DOM 的支持则彼此相差比较多。对已经正式纳入 HTML5 标准的 BOM 来说，尽管各浏览器都实现了某些众所周知的共同特性，但其他特性还是会因浏览器而异。</p><h2 id="在-HTML-中使用-JavaScript"><a href="#在-HTML-中使用-JavaScript" class="headerlink" title="在 HTML 中使用 JavaScript"></a>在 HTML 中使用 JavaScript</h2><h3 id="lt-script-gt-元素"><a href="#lt-script-gt-元素" class="headerlink" title="&lt;script&gt;元素"></a><code>&lt;script&gt;</code>元素</h3><p>向 HTML 页面中插入 JavaScript 的主要方法是使用<code>&lt;script&gt;</code>元素。<code>HTML4.01</code> 为<code>&lt;script&gt;</code>定义了下列6个属性：</p><ul><li><code>async</code>：可选。表示应该立即下载脚本，但不应妨碍页面中的其他操作，比如下载其他资源或等待加载其他脚本。只对外部脚本文件有效</li><li><code>charset</code>：可选。表示通过src属性指定的代码的字符集。由于大多数浏览器会忽略该属性的值，因此这个属性很少有人用</li><li><code>defer</code>：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效</li><li><code>language</code>：已废弃</li><li><code>src</code>：可选。表示包含要执行代码的外部文件</li><li><code>type</code>：可选。可以看成是 <code>language</code> 的替代属性；表示编写代码使用的脚本语言的内容类型（即 <code>MIME</code> 类型）。虽然 <code>text/javscript</code> 和 <code>text/ecmascript</code> 都不被推荐使用，但人们一直以来使用的都还是 <code>text/javascript</code>。实际上，服务器在传送 <code>JavaScript</code> 文件时使用的<code>MIME</code>类型通常是 <code>application/x-javascript</code> ，但在 <code>type</code> 中设置这个值却可能导致脚本被忽略。另外，在非IE浏览器中还可以使用以下值：<code>application/javascript</code> 和 <code>application/ecmascript</code>。考虑到约定俗成和最大限度的浏览器兼容性，目前 <code>type</code> 属性的值依旧还是 <code>text/javascript</code>。不过，这个属性并不是必须的，如果没有指定这个属性，则其默认值仍是 <code>text/javascript</code>。</li></ul><p>使用<code>&lt;script&gt;</code>元素的方式有两种：直接在页面中嵌入 <code>JavaScript</code>代码和包含外部 <code>JavaScript</code> 文件。</p><p>包含在<code>&lt;script&gt;</code>元素内部的 <code>JavaScript</code> 代码将被从上到下依次解释。在解释器对<code>&lt;script&gt;</code>元素内部的所有代码求值完毕以前，页面中的其余内容都不会被浏览器加载或显示。</p><p>在使用<code>&lt;script&gt;</code>嵌入 <code>JavaScript</code> 代码时，当浏览器遇到字符串<code>&lt;/script&gt;</code>时，就会认为该处即为结束的<code>&lt;/script&gt;</code>标签。我们可以通过转义字符 <code>“\”</code> 将 <code>&quot;/&quot;</code> 转义为 <code>“\/”</code>  解决这个问题。</p><p>若要通过<code>&lt;script&gt;</code>元素来包含外部 <code>JavaScript</code> 文件，则需为其添加 <code>src</code> 属性。这个属性的值是一个指向外部 <code>JavaScript</code> 文件的链接，也可以用来指向外部域。需要注意的是，指向的外部域必需要是可信任的。另外带有<code>src</code>属性的<code>&lt;script&gt;</code>元素若在其<code>&lt;script&gt;</code>和<code>&lt;/script&gt;</code>标签之间再包含额外的 <code>JavaScript</code> 代码，则包含的代码会被忽略。</p><p>若页面中包含多个<code>&lt;script&gt;</code>标签，且标签均无 <code>defer</code> 和 <code>async</code> 属性，浏览器就会从第一个<code>&lt;script&gt;</code>标签依次进行解析。</p><h4 id="标签的位置"><a href="#标签的位置" class="headerlink" title="标签的位置"></a>标签的位置</h4><p>传统的做法是,所有<code>&lt;script&gt;</code>标签的位置一般放在<code>&lt;head&gt;</code>中。但在项目应用中，<code>&lt;script&gt;</code>标签的位置一般放在<code>&lt;body&gt;</code>后面。</p><h4 id="延迟脚本"><a href="#延迟脚本" class="headerlink" title="延迟脚本"></a>延迟脚本</h4><p><code>&lt;script&gt;</code>标签可以添加<code>defer</code>属性，来告诉浏览器应当立即下载，但要延迟到整个页面解析完毕再执行。<code>HTML5</code> 规范要求脚本按照它们出现的先后顺序执行，因此第一个延迟脚本会先于第二个延迟脚本执行，而这两个脚本会先于 <code>DOMContentLoaded</code> 事件执行。在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 <code>DOMContentLoaded</code> 事件触发前执行，因此最好只包含一个延迟脚本。</p><h4 id="异步脚本"><a href="#异步脚本" class="headerlink" title="异步脚本"></a>异步脚本</h4><p><code>&lt;script&gt;</code>标签可以添加 <code>async</code> 属性，来告诉浏览器应当立即下载，但与 <code>defer</code> 属性不同的是，标记为 <code>async</code> 的脚本并不保证按照其先后顺序执行。异步脚本一定会在页面的 <code>load</code> 事件前执行，但可能会在 <code>DOMContentLoaded</code> 事件触发之前或之后执行。</p><h3 id="嵌入代码与外部文件"><a href="#嵌入代码与外部文件" class="headerlink" title="嵌入代码与外部文件"></a>嵌入代码与外部文件</h3><p>嵌入代码指在 <code>HTML</code> 文件中嵌入 <code>JavaScript</code> 代码。但一般认为最好的做法还是使用外部文件来包含 <code>JavaScript</code> 代码。使用外部文件会有以下优点：</p><ul><li>可维护性：将 <code>JavaScript</code> 代码放在一个位置统一管理，便于维护</li><li>可缓存：浏览器可以根据具体的设置缓存链接的所有外部 <code>JavaScript</code> 文件，加快页面加载速度</li><li>适应未来：通过外部文件来包含 <code>JavaScript</code> 无须使用 <code>XHTML</code> 或注释 <code>hack</code>。<code>HTML</code> 和 <code>XHTML</code> 包含外部文件的语法是相同的。</li></ul><h3 id="文档模式"><a href="#文档模式" class="headerlink" title="文档模式"></a>文档模式</h3><p>文档模式这个概念是 <code>IE5.5</code> 引入的，最初的两种文档模式是：混杂模式和标准模式。<code>HTML5</code> 通过使用下述文档类型来开启：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- HTML 5 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br></pre></td></tr></table></figure><h3 id="lt-noscript-gt-元素"><a href="#lt-noscript-gt-元素" class="headerlink" title="&lt;noscript&gt; 元素"></a><code>&lt;noscript&gt;</code> 元素</h3><p><code>&lt;noscript&gt;</code>用以在不支持 <code>JavaScript</code> 的浏览器中显示替代的内容。包含在<code>&lt;noscript&gt;</code>标签中的内容只有在下列情况才会显示：</p><ul><li>浏览器不支持脚本</li><li>浏览器支持脚本，但脚本被禁用</li></ul><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>将 <code>JavaScript</code> 插入到 <code>HTML</code> 页面中需要使用<code>&lt;script&gt;</code>元素。需要注意的是：</p><ul><li>在包含外部 <code>JavaScript</code> 文件时，必须把 <code>src</code> 属性设置为指向相应文件的 <code>URL</code>。而这个文件既可以是与包含它的页面位于同一个服务器上的文件，也可以是其他任何域中的文件</li><li>所有的<code>&lt;script&gt;</code>元素都会按它们在页面中出现的先后顺序依次被解析。在不适用 <code>defer</code> 和 <code>async</code> 属性时，只有在解析完前面<code>&lt;script&gt;</code>中的代码之后，才会开始解析后面<code>&lt;script&gt;</code>中的代码</li><li>由于浏览器会解析完不使用 <code>defer</code> 属性的<code>&lt;script&gt;</code>中的代码再解析后面的内容，所以一般应该把<code>&lt;script&gt;</code>元素放在页面最后面，即主要内容后面，<code>&lt;/body&gt;</code>前面</li><li>使用 <code>defer</code> 属性可以让脚本在文档完全呈现后再执行。延迟脚本总是按照指定它们的顺序执行</li><li>使用<code>async</code>属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照他们在页面中出现的顺序执行。</li></ul><p>在不支持脚本的浏览器中显示替代内容可使用<code>&lt;noscript&gt;</code>元素。若启用脚本，则浏览器不会显示<code>&lt;noscript&gt;</code>元素中的任何内容。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>ECMAScript 的语法大量借鉴了 C 及其他类 C 语言（如 <code>Java</code> 和 <code>Perl</code> ）的语法。</p><h3 id="区分大小写"><a href="#区分大小写" class="headerlink" title="区分大小写"></a>区分大小写</h3><p>ECMAScript 中的一切（变量、函数名和操作符）都区分大小写。</p><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>标识符指的是变量、函数、属性的名字，或者函数的参数。标识符的第一个字符必须是一个字母、下划线<code>_</code>或者美元符号<code>$</code></p><p>通常 ECMAScript 标识符采用驼峰大小写格式。即第一个字母小写，剩下每个单词的首字母大写。</p><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>严格模式是为 <code>JavaScript</code> 定义了一种不同的解析与执行步骤。在严格模式下，<code>ECMAScript3</code> 中的一些不确定行为将得到处理，并且会对某些不安全操作会拋错。</p><p>在整个 <code>JavaScript</code> 开启严格模式方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">"use strict"</span></span><br></pre></td></tr></table></figure><p>指定函数在严格模式下执行：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dosth</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line">    <span class="comment">// 函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>ECMAScript 中语句结尾一般以分号结尾，虽然不是必需的，但加上分号可以避免错误，解析器也不必花时间推测应该在哪里插入分号。</p><p>控制语句中要用代码块<code>{}</code>。</p><h3 id="关键字和保留字"><a href="#关键字和保留字" class="headerlink" title="关键字和保留字"></a>关键字和保留字</h3><p>关键字和保留字不能用作标识符。</p><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>ECMAScript 的变量是松散类型的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg = <span class="string">'hi'</span>;</span><br></pre></td></tr></table></figure><p>这样初始化变量并不会把它标记为字符串类型，因此可以在修改变量的同时修改值的类型，但不建议修改变量所保存值的类型。</p><p>使用 <code>var</code> 定义的变量将成为定义这个变量所在作用域中的局部变量，变量在函数退出后会被销毁。若省略 <code>var</code> 创建的变量为全局变量，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testUseVar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> msg = <span class="string">'useVar'</span></span><br><span class="line">&#125;</span><br><span class="line">testUseVar()</span><br><span class="line"><span class="built_in">console</span>.log(msg)<span class="comment">// Uncaught ReferenceError: msg is not defined</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">testDontUseVar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    msg = <span class="string">'dontUseVar'</span></span><br><span class="line">&#125;</span><br><span class="line">testDontUseVar()</span><br><span class="line"><span class="built_in">console</span>.log(msg)<span class="comment">// msg</span></span><br></pre></td></tr></table></figure><p>在严格模式下，不能定义名为 <code>eval</code> 或 <code>arguments</code> 的变量，否则会导致语法错误。</p><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>ECMAScript 中有五种简单数据类型（基本数据类型）以及一种复杂数据类型。具体如下：</p><ul><li><code>Undefined</code></li><li><code>Null</code></li><li><code>Boolean</code></li><li><code>Number</code></li><li><code>String</code></li><li><code>Object</code>——复杂数据类型</li></ul><h4 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h4><p><code>typeof</code> 用来检测给定变量的数据类型，返回值如下：</p><ul><li><code>undefined</code>：值未定义</li><li><code>boolean</code>：布尔值</li><li><code>string</code>：字符串</li><li><code>number</code>：数值</li><li><code>object</code>：对象或 null</li><li><code>function</code>：函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">'some string'</span>)<span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">90</span>)<span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">null</span>)<span class="comment">// object</span></span><br></pre></td></tr></table></figure><p>特殊值 <code>null</code> 会被认为是一个空对象的引用。</p><h4 id="Undefined-类型"><a href="#Undefined-类型" class="headerlink" title="Undefined 类型"></a>Undefined 类型</h4><p><code>Undefined</code> 类型只有一个值：<code>undefined</code>。使用 var 声明变量但未初始化时，这个变量的值就是 <code>undefined</code> ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg<span class="comment">// 等同于 var msg = undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(msg === <span class="literal">undefined</span>)<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>未初始化的变量 与未定义的变量是两个概念：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg<span class="comment">// 已声明(定义)</span></span><br><span class="line"><span class="built_in">console</span>.log(msg)<span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// var age// 未定义</span></span><br><span class="line"><span class="built_in">console</span>.log(age)<span class="comment">// Uncaught ReferenceError: msg is not defined</span></span><br></pre></td></tr></table></figure><p>但使用 <code>typeof</code> 操作符检测未初始化的变量及未声明的变量，返回值均为 <code>undefined</code>：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> msg<span class="comment">// 已声明(定义)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> msg)<span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// var age// 未定义</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> age)<span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>综上，未初始化的变量与未声明的变量虽然有本质的区别，但实际中对两种变量都无法执行真正的操作。</p><h4 id="Null-类型"><a href="#Null-类型" class="headerlink" title="Null 类型"></a>Null 类型</h4><p><code>Null</code> 类型也同样只有一个值：<code>null</code>。</p><p><code>null</code> 表示一个空对象指针。这也是 <code>typeof</code> 操作符检测 <code>null</code> 返回 ’<code>object</code>‘ 的原因。若定义变量是用来保存对象，最好将其初始化为 <code>null</code> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="literal">undefined</span>)<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>出现上述输出结果的原因是 <code>undefined</code> 值是派生自 <code>null</code> 值的，因此 ECMA-262 规定对他们的相等性测试要返回 <code>true</code>。但两者也有区别之处：<strong>没必要把一个变量的值显式的设置为 <code>undefined</code> ，但一个用来保存对象的变量在未保存对象之前就应该保存 <code>null</code> 值。</strong>这样做既可以体现 <code>null</code> 作为空对象指针的惯例，也有助于区分两者。</p><h4 id="Boolean-类型"><a href="#Boolean-类型" class="headerlink" title="Boolean 类型"></a>Boolean 类型</h4><p><code>Boolean</code> 类型是 ECMAScript 中使用的最多的一种类型，字面值只有 <code>true</code> 和 <code>false</code>。</p><p>可以对任意数据类型的值调用转型函数 <code>Boolean()</code> 函数，对应转换规则如下：</p><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">转换为true的值</th><th style="text-align:center">转换为false的值</th></tr></thead><tbody><tr><td style="text-align:center">Boolean</td><td style="text-align:center">true</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">String</td><td style="text-align:center">任何非空字符串</td><td style="text-align:center">“”（空字符串）</td></tr><tr><td style="text-align:center">Number</td><td style="text-align:center">任何非零数值（包括无穷大）</td><td style="text-align:center">0 和 NaN</td></tr><tr><td style="text-align:center">Object</td><td style="text-align:center">任何对象</td><td style="text-align:center">null</td></tr><tr><td style="text-align:center">Undefined</td><td style="text-align:center">N/A（不适用）</td><td style="text-align:center">undefined</td></tr></tbody></table><p>流控制语句（如 <code>if</code> 语句）会自动执行相应的 <code>Boolean</code> 转换。</p><h4 id="Number-类型"><a href="#Number-类型" class="headerlink" title="Number 类型"></a>Number 类型</h4><p>最基本的数值字面量格式是十进制整数，除了十进制外，整数还可以通过八进制或十六进制的字面值来表示。</p><p>八进制字面值的第一位必须是零（0），然后是八进制数字序列（0-7）。若字面值超出范围，则该值会被当作十进制数值解析。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> octalNum1 = <span class="number">070</span><span class="comment">// 八进制56</span></span><br><span class="line"><span class="keyword">var</span> octalNum2 = <span class="number">079</span><span class="comment">// 无效八进制数值，解析为79</span></span><br><span class="line"><span class="keyword">var</span> octalNum2 = <span class="number">08</span><span class="comment">// 无效八进制数值，解析为8</span></span><br></pre></td></tr></table></figure><p>十六进制数值前两位必须是 0x ，后跟任何十六进制数字（0-9，A-F）。其中字母可大写也可小写。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hexNum1 = <span class="number">0xA</span><span class="comment">// 十六进制10</span></span><br><span class="line"><span class="keyword">var</span> hexNum2 = <span class="number">0x1f</span><span class="comment">// 十六进制31</span></span><br></pre></td></tr></table></figure><h5 id="浮点数值"><a href="#浮点数值" class="headerlink" title="浮点数值"></a>浮点数值</h5><p>数值中包含小数点，切小数点后至少有一位数字。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> floatNum1 = <span class="number">1.1</span></span><br><span class="line"><span class="keyword">var</span> floatNum2 = <span class="number">0.1</span></span><br><span class="line"><span class="keyword">var</span> floatNum3 = <span class="number">.1</span><span class="comment">// 有效，不推荐</span></span><br></pre></td></tr></table></figure><p>若一个数值小数点后无任何数字，或数值本身表示的就是一个整数，则该数值会被解析为整数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> floatNum1 = <span class="number">1.</span><span class="comment">// 解析为1</span></span><br><span class="line"><span class="keyword">var</span> floatNum1 = <span class="number">20.0</span><span class="comment">// 解析为20</span></span><br></pre></td></tr></table></figure><p>对于极大或极小的数值，可以用科学计数法表示的浮点数值表示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> floatNum = <span class="number">1.45e6</span><span class="comment">// 等于1450000</span></span><br></pre></td></tr></table></figure><p>上述例子中，1.45e6 = $1.45*10^6$。</p><p>浮点数值最高精度是17位小数，但在进行算数计算时其精度远远不如整数。</p><p>例如，<code>0.1</code> 加 <code>0.2</code> 的结果不是 <code>0.3</code>，而是 <code>0.30000000000000004</code>，这是使用基于<br><code>IEEE754</code> 数值的浮点计算的通病，ECMAScript 并非独此一家;其他使用相同数值格<br>式的语言也存在这个问题。</p><h5 id="数值范围"><a href="#数值范围" class="headerlink" title="数值范围"></a>数值范围</h5><p>ECMAScript 能表示的最小数值为 <code>Number.MIN_VALUE</code> ——在大多数浏览器中为<code>5e-324</code>，最大数值为<code>Number.MAX_VALUE</code>——在大多数浏览器中为<code>1.7976931348623157e+308</code>。</p><p>若某次计算结果超出该范围，则结果会被自动转换成特殊的 <code>Infinity</code>（正无穷）或 <code>-Infinity</code>（负无穷），且该结果无法继续参与下一次的计算。</p><p>可以使用 <code>isFinite()</code> 函数来确定一个数值是否在最大值与最小值之间，返回值为 <code>true</code>或<code>false</code> 。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res = <span class="built_in">Number</span>.MAX_VALUE + <span class="built_in">Number</span>.MAX_VALUE</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isFinite</span>(res))<span class="comment">// false</span></span><br></pre></td></tr></table></figure><h5 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h5><p><code>NaN</code>（Not a Number）是一个特殊数值，用于表示一个本来要返回数值的操作数未返回数值的情况。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">5</span> / <span class="number">0</span>)<span class="comment">// Infinity</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">-5</span> / <span class="number">0</span>)<span class="comment">// -Infinity</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0</span> / <span class="number">0</span>)<span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><p><code>NaN</code> 具有以下两个特点：</p><ul><li>任何涉及 <code>NaN</code> 的操作都会返回 <code>NaN</code></li><li><code>NaN</code> 与任何值都不相等，包括其本身</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>)<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>isNaN()</code> 函数可以接受一个任何类型的参数并且确定这个参数是不是数值。该函数在接收到一个值后会尝试将该值转换为数值，若可以转换成功则返回 <code>false</code>，否则将返回 <code>true</code>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>))<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="number">100</span>))<span class="comment">// false(10)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">'200'</span>))<span class="comment">// false(200)</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">'red'</span>))<span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">false</span>))<span class="comment">// false(0)</span></span><br></pre></td></tr></table></figure><h5 id="数值转换"><a href="#数值转换" class="headerlink" title="数值转换"></a>数值转换</h5><p>可以通过 <code>Number()</code> 、<code>parseInt()</code> 和 <code>parseFloat()</code> 三个函数将非数值转换为数值。</p><p><code>Number()</code> 转换规则：</p><ul><li>若为 <code>Boolean</code> 值，<code>true</code> 和 <code>false</code> 分别转换为1和0</li><li>若为数值，只是简单地传入和返回</li><li>若为 <code>null</code> ，返回0</li><li>若为<code>undefined</code>，返回 <code>NaN</code></li><li>若为字符串，按以下规则：<ul><li>若字符串中只包含数字，包括前面带正负号的情况，则将其转换为十进制数值，忽略前导零</li><li>若字符串中包含有效的浮点格式，则将其转换为相应的浮点数值，忽略前导零</li><li>若字符串中包含有效的十六进制格式，将其转换为相同大小的十进制整数值</li><li>若字符串是空的，则将其转换为0</li><li>若字符串中包含除上述格式之外的字符，则将其转换为 <code>NaN</code></li></ul></li><li>若为对象，则调用对象的 <code>valueOf()</code> 方法，然后依照前面规则转换。若转换的结果是 <code>NaN</code>，则调用对象的 <code>toString()</code> 方法，然后依照前面规则转换</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">Number</span>(<span class="string">'hello world'</span>)<span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">Number</span>(<span class="string">''</span>)<span class="comment">// 0</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">Number</span>(<span class="string">'00032'</span>)<span class="comment">// 11</span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">Number</span>(<span class="literal">true</span>)<span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p><code>parseaInt()</code> 转换规则：</p><p>使用 <code>parseInt()</code> 转换字符串时，会忽略字符串前面的空格，直至找到第一个非空字符，若第一个字符不是数字字符或正负号，会返回 <code>NaN</code> 。若第一个字符是数字字符，该函数在继续解析后续字符时若遇到非数字字符则会将已解析的值返回，否则将解析完所有后续字符。并且该函数还可以识别各种整数格式（八进制，十进制，十六进制）。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">'123red'</span>)<span class="comment">// 123</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">''</span>)<span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseInt</span>(<span class="string">'0xA'</span>)<span class="comment">// 10(十六进制数)</span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseInt</span>(<span class="number">22.5</span>)<span class="comment">// 22</span></span><br><span class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseInt</span>(<span class="string">'070'</span>)<span class="comment">// 56(八进制数)</span></span><br><span class="line"><span class="keyword">var</span> num6 = <span class="built_in">parseInt</span>(<span class="string">'70'</span>)<span class="comment">// 70(十进制数)</span></span><br><span class="line"><span class="keyword">var</span> num7 = <span class="built_in">parseInt</span>(<span class="string">'0xf'</span>)<span class="comment">// 15(十六进制数)</span></span><br></pre></td></tr></table></figure><p>使用 <code>parseInt()</code> 解析八进制字面量的字符串时，ECMAScript3 和 5 存在分歧：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="built_in">parseInt</span>(<span class="string">'070'</span>)</span><br><span class="line"><span class="comment">// ECMAScript3 会输出56(八进制)，ECMAScript5 会输出70(十进制)</span></span><br></pre></td></tr></table></figure><p>为了解决这个问题，在使用 <code>parseInt()</code> 函数时可以提供第二个参数作为转换基数，即多少进制。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseInt</span>(<span class="string">'10'</span>,<span class="number">2</span>)<span class="comment">//2按二进制解析</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseInt</span>(<span class="string">'10'</span>,<span class="number">8</span>)<span class="comment">//8按八进制解析</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseInt</span>(<span class="string">'10'</span>,<span class="number">10</span>)<span class="comment">//10按十进制解析</span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseInt</span>(<span class="string">'10‘,16)//16按十六进制解析</span></span><br></pre></td></tr></table></figure><p><code>parseFloat()</code> 转换规则：</p><p><code>parseFloat()</code> 从第一个字符开始解析，一直到字符串末尾或者一个无效的浮点数为止。字符串中第一个小数点有效，第二个小数点后无效。另外，该函数始终会忽略前导零。<code>parseFloat()</code> 只解析十进制值，因此没有用第二个参数指定基数的用法，若字符串包含的是一个可解析为整数的数，则返回整数。</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num1 = <span class="built_in">parseFloat</span>(<span class="string">'1234red'</span>)<span class="comment">// 1234</span></span><br><span class="line"><span class="keyword">var</span> num2 = <span class="built_in">parseFloat</span>(<span class="string">'0xA'</span>)<span class="comment">// 0</span></span><br><span class="line"><span class="keyword">var</span> num3 = <span class="built_in">parseFloat</span>(<span class="string">'22.5'</span>)<span class="comment">// 22.5</span></span><br><span class="line"><span class="keyword">var</span> num4 = <span class="built_in">parseFloat</span>(<span class="string">'22.34.5'</span>)<span class="comment">// 22.34</span></span><br><span class="line"><span class="keyword">var</span> num5 = <span class="built_in">parseFloat</span>(<span class="string">'090.3'</span>)<span class="comment">// 90.3</span></span><br><span class="line"><span class="keyword">var</span> num6 = <span class="built_in">parseFloat</span>(<span class="string">'3.125e7'</span>)<span class="comment">// 31250000</span></span><br></pre></td></tr></table></figure><h4 id="String-类型"><a href="#String-类型" class="headerlink" title="String 类型"></a>String 类型</h4><p><code>String</code> 类型用于表示由零或多个16位 <code>Unicode</code> 字符组成的字符序列，即字符串。</p><h5 id="字符字面量"><a href="#字符字面量" class="headerlink" title="字符字面量"></a>字符字面量</h5><p><code>String</code> 数据类型包含一些特殊的字符字面量，也叫转义序列，用于表示非打印或具有其他用途的字符，如下：</p><table><thead><tr><th style="text-align:center">字面量</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td style="text-align:center">\n</td><td style="text-align:center">换行</td></tr><tr><td style="text-align:center">\t</td><td style="text-align:center">制表</td></tr><tr><td style="text-align:center">\b</td><td style="text-align:center">空格</td></tr><tr><td style="text-align:center">\r</td><td style="text-align:center">回车</td></tr><tr><td style="text-align:center">\f</td><td style="text-align:center">进纸</td></tr><tr><td style="text-align:center">\</td><td style="text-align:center">斜杠</td></tr><tr><td style="text-align:center">\’</td><td style="text-align:center">单引号</td></tr><tr><td style="text-align:center">\”</td><td style="text-align:center">双引号</td></tr><tr><td style="text-align:center">\xnn</td><td style="text-align:center">以十六进制代码nn表示的一个字符（n为0~F）</td></tr><tr><td style="text-align:center">\unnnn</td><td style="text-align:center">以十六机制代码nnnn表示的一个Unicode字符（n为0~F）</td></tr></tbody></table><p>每个转移序列表示一个字符，字符串的长度可以通过访问 <code>length</code> 属性获取。</p><h5 id="字符串特点"><a href="#字符串特点" class="headerlink" title="字符串特点"></a>字符串特点</h5><p> ECMAScript中的字符串一旦创建，值就不能改变。如果要改变某变量保存的字符串，则需要将原字符串销毁，再用另外一个包含新值得字符串填充改变量。</p><h5 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h5><p>将一个值转为一个字符串有两种方法：<code>toString()</code> 和 <code>String()</code> 。需要注意的是，<code>null</code> 和 <code>undefined</code> 没有 <code>toString()</code> 方法，而 <code>String()</code> 函数对所有类型的值都适用。<code>String()</code> 函数遵循以下转换规则：</p><ul><li>如果值有 <code>toString()</code> 方法，则调用该方法（没有参数）并返回相应结果</li><li>如果值是 <code>null</code> ，则返回 <code>&quot;null&quot;</code></li><li>如果值是 <code>undefined</code> ，则返回 <code>&quot;undefined&quot;</code></li></ul><h4 id="Object-类型"><a href="#Object-类型" class="headerlink" title="Object 类型"></a>Object 类型</h4><p><code>Object</code> 类型所具有的任何属性和方法也同样存在于更具体的对象中。<code>Object</code> 的每个实例都具有下列属性和方法：</p><ul><li><code>constructor</code>：保存着用于创建当前对象的函数</li><li><code>hasOwnProperty(propertyName)</code>：用于检查给定的属性是否存在于当前对象实例中（而非在实例的原型中），其中 <code>propertyName</code> 必须以字符串形式指定</li><li><code>isPrototypeOf(object)</code> ：用于检查传入的对象是否是传入对象的原型</li><li><code>propertyIsEnumerable(propertyName)</code> ：用于检查给定属性是否能够使用 <code>for-in</code> 语句来枚举</li><li><code>toLocaleString()</code> ：返回对象的字符串表示，该字符串与执行环境的地区对应</li><li><code>toString()</code> ：返回对象的字符串表示</li><li><code>valueOf()</code> ：返回对象的字符串、数值或布尔值表示，通常与 <code>toString()</code> 方法的返回值相同</li></ul><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><h4 id="一元操作符"><a href="#一元操作符" class="headerlink" title="一元操作符"></a>一元操作符</h4><p>只操作一个值的操作符叫一元操作符。</p><h5 id="递增和递减操作符"><a href="#递增和递减操作符" class="headerlink" title="递增和递减操作符"></a>递增和递减操作符</h5><p>递增和递减操作符各有两个版本：前置型和后置型。</p><p>执行前置递增和递减操作时，变量的值都是在语句被求值以前改变的。</p><p>执行后置递增和递减操作时，该操作是在包含它们的语句被求值后才执行的。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前置递增递减操作符</span></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="number">20</span></span><br><span class="line"><span class="built_in">console</span>.log(--num1 + num2)<span class="comment">// 21</span></span><br><span class="line"><span class="built_in">console</span>.log(num1 + num2)<span class="comment">// 21</span></span><br><span class="line"><span class="comment">// 后置递增递减操作符</span></span><br><span class="line"><span class="keyword">let</span> num3 = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> num4 = <span class="number">20</span></span><br><span class="line"><span class="built_in">console</span>.log(num3-- + num4)<span class="comment">// 22</span></span><br><span class="line"><span class="built_in">console</span>.log(num3 + num4)<span class="comment">// 21</span></span><br></pre></td></tr></table></figure><p>以上四个操作符适用于任何值，在应用于不同的值得时候，遵循以下规则，输出值均为数值变量：</p><ul><li>应用于字符串，若字符串包含有效字符，将其转为数字值再进行加减1操作</li><li>应用于字符串，若字符串不包含有效数字字符，返回值为 <code>NaN</code></li><li>应用于布尔值，将 <code>false</code> 转为0，<code>true</code> 转为1，再执行加减1操作</li><li>应用于浮点数值时，直接执行加减1操作</li><li>应用于对象时，先调用对象的 <code>valueOf()</code> 方法取得一个可供操作的值后再对该值进行前述规则，若结果是 <code>NaN</code> 则调用 <code>toString()</code> 方法再应用前述规则</li></ul><p>示例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">'2'</span>, s2 = <span class="string">'z'</span>, b = <span class="literal">false</span>, f = <span class="number">1.1</span></span><br><span class="line"><span class="keyword">let</span> o = &#123;</span><br><span class="line">    valueOf:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">s1++<span class="comment">// 3</span></span><br><span class="line">s2++<span class="comment">// NaN</span></span><br><span class="line">b++<span class="comment">// 1</span></span><br><span class="line">f--<span class="comment">// 0.10000000000000009(由于浮点舍入错误所致)</span></span><br><span class="line">o--<span class="comment">// -2</span></span><br></pre></td></tr></table></figure><h5 id="一元加和减操作符"><a href="#一元加和减操作符" class="headerlink" title="一元加和减操作符"></a>一元加和减操作符</h5><p>对非数值应用一元加减操作符（ <code>+</code> ，<code>-</code> ）时，该操作符会像 <code>Number()</code>转型函数一样对这个值执行隐式转换。因此一元加减操作符主要用于基本的算术运算，也可以用于转换数据类型。</p><h4 id="位操作符"><a href="#位操作符" class="headerlink" title="位操作符"></a>位操作符</h4><h5 id="按位非（NOT）"><a href="#按位非（NOT）" class="headerlink" title="按位非（NOT）"></a>按位非（NOT）</h5><p>按位非操作符由 “~” 表示，执行按位非得结果就是返回数值的反码。</p><p>按位非操作的本质:操作数的负值减 1。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> num1 = <span class="number">25</span><span class="comment">// 二进制00000000000000000000000000011001</span></span><br><span class="line"><span class="keyword">let</span> num2 = ~num1<span class="comment">// 二进制11111111111111111111111111100110</span></span><br><span class="line"><span class="built_in">console</span>.log(num2)<span class="comment">// -26</span></span><br></pre></td></tr></table></figure><h5 id="按位与（AND）"><a href="#按位与（AND）" class="headerlink" title="按位与（AND）"></a>按位与（AND）</h5><p>按位与操作符由 <code>&amp;</code> 表示，有两个操作数</p><table><thead><tr><th style="text-align:center">&amp;</th></tr></thead><tbody><tr><td style="text-align:center">1 &amp; 1 = 1</td></tr><tr><td style="text-align:center">1 &amp; 0 = 0</td></tr><tr><td style="text-align:center">0 &amp; 1 = 0</td></tr><tr><td style="text-align:center">0 &amp; 0 = 0</td></tr></tbody></table><p>按位与操作只在两个数值的对应位都是 1 时才返回 1，任何一位是 0，结果都是 0</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">25</span> &amp; <span class="number">3</span>)<span class="comment">// 1</span></span><br><span class="line"> <span class="number">25</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1001</span></span><br><span class="line">  <span class="number">3</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span> </span><br><span class="line">---------------------------------------------</span><br><span class="line">AND = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span></span><br></pre></td></tr></table></figure><h5 id="按位或（OR）"><a href="#按位或（OR）" class="headerlink" title="按位或（OR）"></a>按位或（OR）</h5><p>按位或操作符由 <code>|</code> 表示，有两个操作数</p><table><thead><tr><th style="text-align:center">\</th><th></th></tr></thead><tbody><tr><td style="text-align:center">1 \</td><td>1 = 1</td></tr><tr><td style="text-align:center">1 \</td><td>0 = 1</td></tr><tr><td style="text-align:center">0 \</td><td>1 = 1</td></tr><tr><td style="text-align:center">0 \</td><td>0 = 0</td></tr></tbody></table><p>按位或操作在有一个位是 1 的情况下就返回 1，而只有在两个位都是 0 的情况下才返回 0</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">25</span> | <span class="number">3</span>)<span class="comment">// 27</span></span><br><span class="line"><span class="number">25</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1001</span> </span><br><span class="line"> <span class="number">3</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span> </span><br><span class="line">-------------------------------------------- </span><br><span class="line">OR = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1011</span></span><br></pre></td></tr></table></figure><h5 id="按位异或（XOR）"><a href="#按位异或（XOR）" class="headerlink" title="按位异或（XOR）"></a>按位异或（XOR）</h5><p>按位或操作符由 <code>^</code> 表示，有两个操作数</p><table><thead><tr><th style="text-align:center">^</th></tr></thead><tbody><tr><td style="text-align:center">1 ^ 1 = 0</td></tr><tr><td style="text-align:center">1 ^ 0 = 1</td></tr><tr><td style="text-align:center">0 ^ 1 = 1</td></tr><tr><td style="text-align:center">0 ^ 0 = 0</td></tr></tbody></table><p>按位异或与按位或的不同之处在于，这个操作在两个数值对应位上只有一个 1 时才返回 1，如果对应的两位都是 1 或都是 0，则返回 0</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">25</span> ^ <span class="number">3</span>)<span class="comment">//26</span></span><br><span class="line"> <span class="number">25</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1001</span> </span><br><span class="line">  <span class="number">3</span> = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0011</span> </span><br><span class="line">--------------------------------------------- </span><br><span class="line">XOR = <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0000</span> <span class="number">0001</span> <span class="number">1010</span></span><br></pre></td></tr></table></figure><h5 id="左移"><a href="#左移" class="headerlink" title="左移"></a>左移</h5><p>左移操作符由 <code>&lt;&lt;</code> 表示，这个操作符会将数值的所有位向左移动指定的位数，左移会在原数值的右侧出现的空位，用0来填充。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oldVal = <span class="number">2</span><span class="comment">// 二进制的10</span></span><br><span class="line"><span class="keyword">let</span> newVal = oldVal &lt;&lt; <span class="number">5</span><span class="comment">// 二进制的1000000，十进制的64</span></span><br><span class="line">注：左移不会影响操作数的符号位，即左移不会改变数值的正负</span><br></pre></td></tr></table></figure><h5 id="右移"><a href="#右移" class="headerlink" title="右移"></a>右移</h5><p>右移分为有符号右移和无符号右移两种情况。</p><p>有符号右移：</p><p>操作符为 <code>&gt;&gt;</code> 表示，该操作符会将数值向右移动，但保留负号位，右移会在原数值的左侧，符号位的右侧出现空位，此时会用符号位的值来填充所有空位。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oldVal = <span class="number">64</span><span class="comment">// 二进制1000000</span></span><br><span class="line"><span class="keyword">let</span> newVal = oldVal&gt;&gt;<span class="number">5</span><span class="comment">// 二进制的10，十进制的2</span></span><br></pre></td></tr></table></figure><p>无符号右移：</p><p>无符号右移由 <code>&gt;&gt;&gt;</code> 表示，该操作符会将数值的所有32位都右移，对正数来讲，无符号右移的结果与有符号右移相同，对负数来讲，无符号右移操作符会将负数的二进制码当做正数的二进制码，由于负数以其绝对值的二进制补码形式表示，因此会导致无符号右移之后的结果非常大。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oldVal = <span class="number">-64</span><span class="comment">// 二进制的11111111111111111111111111000000</span></span><br><span class="line"><span class="keyword">let</span> newVal = oldVal &gt;&gt;&gt; <span class="number">5</span><span class="comment">// 十进制的134217726</span></span><br></pre></td></tr></table></figure><p>####布尔操作符</p><h5 id="逻辑非"><a href="#逻辑非" class="headerlink" title="逻辑非"></a>逻辑非</h5><p>逻辑非操作符即 <code>!</code> ，可以应用于任何值，先将该值转换为布尔值，再取反，返回一个布尔值。同时对一个值使用两个逻辑非操作符，实际相当于使用 <code>Boolean()</code> 函数，返回值即为该值对应的布尔值</p><ul><li>! 空字符串，返回 <code>true</code></li><li>! 0 ，返回 <code>true</code></li><li>! undefined ，返回 <code>true</code></li><li>! null ，返回 <code>true</code></li><li>! NaN ，返回 <code>true</code></li><li><p>! 非0数值，返回 <code>false</code></p></li><li><p>! 非空字符串，返回 <code>false</code></p></li><li>!对象，返回 <code>false</code> </li></ul><h5 id="逻辑与"><a href="#逻辑与" class="headerlink" title="逻辑与"></a>逻辑与</h5><p>逻辑与由 <code>&amp;&amp;</code> 表示，有两个操作数，真值表如下：</p><table><thead><tr><th style="text-align:center">第一个操作数</th><th style="text-align:center">第二个操作数</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:center">true</td><td style="text-align:center">true</td><td style="text-align:center">true</td></tr><tr><td style="text-align:center">true</td><td style="text-align:center">false</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">false</td><td style="text-align:center">true</td><td style="text-align:center">false</td></tr><tr><td style="text-align:center">false</td><td style="text-align:center">false</td><td style="text-align:center">false</td></tr></tbody></table><p>逻辑与可以应用于任何类型的操作数，不仅仅是布尔值。若有一个操作数不是布尔值，返回结果就不一定是布尔值，遵循规则如下：</p><ul><li>若第一个操作数是对象，返回第二个操作数</li><li>若第二个操作数是对象，只有在第一个操作数求值结果为 <code>true</code> 时才会返回第二个操作数</li><li>若两个操作数都是对象，返回第二个操作数</li><li>若一个操作数是 null ， 返回 null</li><li>若一个操作数是 NaN ，返回 NaN</li><li>若一个操作数是 undefined，返回 undefined</li></ul><p>另外，逻辑与是一个短路操作符。若逻辑与的第一个操作数能决定结果，就不会继续执行逻辑与符号右侧的内容。即若第一个操作数是 false，则结果为false，并结束当前逻辑语句的执行</p><h5 id="逻辑或"><a href="#逻辑或" class="headerlink" title="逻辑或"></a>逻辑或</h5><p>逻辑或操作符由 <code>||</code> 表示，有两个操作数，真值表如下：</p><table><thead><tr><th style="text-align:center">第一个操作数</th><th style="text-align:center">第二个操作数</th><th style="text-align:center">结果</th></tr></thead><tbody><tr><td style="text-align:center">true</td><td style="text-align:center">true</td><td style="text-align:center">true</td></tr><tr><td style="text-align:center">true</td><td style="text-align:center">false</td><td style="text-align:center">true</td></tr><tr><td style="text-align:center">false</td><td style="text-align:center">true</td><td style="text-align:center">true</td></tr><tr><td style="text-align:center">false</td><td style="text-align:center">false</td><td style="text-align:center">false</td></tr></tbody></table><p>与逻辑与操作相似，若一个操作数不是布尔值，逻辑或也不一定返回布尔值。返回结果遵循如下规则：</p><ul><li>若第一个操作数是对象，则返回第一个操作数</li><li>若第一个操作数求值结果是 false，返回第二个操作数</li><li>若两个操作数都是对象，则返回第一个操作数</li><li>若两个操作数都是 null，则返回 null</li><li>若两个操作数都是 NaN，则返回 NaN</li><li>若两个操作数都是 undefined，则返回 undefined</li></ul><p>逻辑或操作符同样也是短路操作符。若第一个操作数的求值结果为 true，则不会对第二个操作数求值。我们可以利用逻辑或的行为来避免为变量赋 null 或 undefined，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myObj = preferredObject || backupObject</span><br><span class="line"><span class="comment">// 赋值过程中，优先取preferredObject，若其转布尔值为 false，则取 backupObject</span></span><br></pre></td></tr></table></figure><h4 id="乘性操作符"><a href="#乘性操作符" class="headerlink" title="乘性操作符"></a>乘性操作符</h4><p>乘性操作符包含乘法，除法，求模。若参与乘性操作的某个操作数不是数值，后台会先将其用  <code>Number()</code> 转型函数转换为数值再进行计算。</p><h5 id="乘法"><a href="#乘法" class="headerlink" title="乘法"></a>乘法</h5><p>乘法操作符由 <code>*</code> 表示，用于计算两个数值的乘积。处理特殊值的情况下，乘法操作符遵循以下规则：</p><ul><li>如果操作数都是数值，则执行常规的乘法计算，若乘积超过 ECMAScript 数值的表示范围，则返回 <code>Infinity</code> 或 <code>-Infinity</code></li><li>若一个操作数是 NaN，则结果是 NaN</li><li>若 <code>Infinity * 0 = NaN</code> </li><li>若 <code>Infinity * 非0</code>  ，结果是 <code>Infinity</code> 或 <code>-Infinity</code>，取决于 非0 数值的符号</li><li><code>Infinity * Infinity = Infinity</code></li><li>若一个操作数不是数值，则在后台调用 <code>Number()</code> 将其转换为数值，然后再应用上面的规则</li></ul><h5 id="除法"><a href="#除法" class="headerlink" title="除法"></a>除法</h5><p>除法操作符由 <code>/</code> 表示，执行第二个操作数除第一个操作数的计算，遵循以下规则：</p><ul><li>若操作数都是数值，执行常规的除法计算，若商超过 ECMAScript 数值的表示范围，则返回 <code>Infinity</code> 或 <code>-Infinity</code></li><li>若一个操作数是 <code>NaN</code> ，则结果为 <code>NaN</code></li><li>若 <code>0 / 0</code> ，结果为 NaN</li><li>若 <code>非0 / 0</code> ，结果为 <code>Infinity</code> 或 <code>-Infinity</code> ，取决于 非0 数值的符号</li><li>若 <code>Infinity / 非0</code> ，结果为 <code>Infinity</code> 或 <code>-Infinity</code> ，取决于 非0 数值的符号</li><li>若一个操作符不是数值，则调用 <code>Number()</code> 将其转换为数值，再应用上述规则</li></ul><h5 id="求模"><a href="#求模" class="headerlink" title="求模"></a>求模</h5><p>求模（余数）操作符由 <code>%</code> 表示，用法如下：</p><ul><li>若操作符都是数值，执行常规除法计算，返回除得的余数</li><li>若 <code>无穷大值 % 有限大值</code> ，结果是 <code>NaN</code></li><li>若 <code>有限大值 % 0</code> ，结果为 <code>NaN</code></li><li>若 <code>Infinity % Infinity</code> ，结果为 <code>NaN</code></li><li>若 <code>有限大值 % 无穷大值</code> ，结果是被除数</li><li>若被除数为0，则结果是0</li><li>若一个操作数不是数值，在后台调用 <code>Number()</code> 将其转换为数值，再应用上述规则</li></ul><h4 id="加性操作符"><a href="#加性操作符" class="headerlink" title="加性操作符"></a>加性操作符</h4><p>与乘性操作符类似，加性操作符也会在后台转换不同的数据类型</p><h5 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h5><p>操作符 <code>+</code> ，执行加法计算，根据下列规则返回结果：</p><ul><li><code>NaN + 任意值 = NaN</code></li><li><code>Infinity + Infinity = Infinity</code></li><li><code>-Infinity + ( -Infinity ) = -Infinity</code></li><li><code>-Infinity + Infinity = NaN</code></li><li><code>+0 + ( +0 ) = +0</code></li><li><code>-0 + ( -0 ) = -0</code></li><li><code>-0 + ( +0 ) = +0</code></li><li><code>字符串1 + 字符串2 = 字符串1与字符串2拼接</code></li><li>只有一个操作数为字符串，则将另一个操作数转为字符串后将两个字符串拼接</li><li>若一个操作数是对象、数值或布尔值，另一个操作数是字符串，则调用 toString() 方法取得相应的字符串，再应用于上述字符串规则</li></ul><h5 id="减法"><a href="#减法" class="headerlink" title="减法"></a>减法</h5><p>操作符 <code>-</code> ，执行减法操作，根据下列规则返回结果：</p><ul><li>若两个操作符都是数值，则执行常规算数减法运算</li><li>若有一个操作数为 <code>NaN</code> ，结果是 <code>NaN</code></li><li><code>Infinity - Infinity = NaN</code></li><li><code>-Infinity - -Infinity = NaN</code></li><li><code>Infinity - -Infinity = Infinity</code></li><li><code>-Infinity - Infinity = -Infinity</code></li><li>+0 - +0 = +0</li><li>+0 - -0 = -0</li><li>-0 - -0 = +0</li><li>若一个操作数是字符串、布尔值、null 、或者 undefined ，先调用 <code>Number()</code> 函数将其转换为数值，再根据前面的规则执行减法计算。若转换结果是 <code>NaN</code> ，减法结果就是 <code>NaN</code></li><li>若一个操作数是对象，则优先调用对象的 <code>valueOf()</code> 方法，若对象没有 <code>valueOf()</code> 方法，则调用其 <code>toString()</code> 方法并将得到的字符串转为数值</li></ul><h4 id="关系操作符"><a href="#关系操作符" class="headerlink" title="关系操作符"></a>关系操作符</h4><p><code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code> 这几个关系操作符用于两个值进行比较，返回一个布尔值</p><p>同其他操作符一样，若操作数使用了非数值，会进行隐式转换，规则如下：</p><ul><li>若均为数值，则执行数值比较</li><li>若都是字符串，则比较两个字符串对应的字符编码值</li><li>若一个操作数为数值，则将另一个操作数转换为数值，再进行比较</li><li>若一个操作数是对象，则调用这个对象的 <code>valueOf()</code> 方法，若没该方法则调用 <code>toString()</code> 方法，并将结果按上述规则进行比较</li><li>若一个操作数是布尔值，则先转换为数值再执行比较</li><li>任何操作数与 <code>NaN</code> 进行关系比较，结果都是 <code>false</code></li></ul><h4 id="相等操作符"><a href="#相等操作符" class="headerlink" title="相等操作符"></a>相等操作符</h4><h5 id="相等和不相等"><a href="#相等和不相等" class="headerlink" title="相等和不相等"></a>相等和不相等</h5><p><code>==</code> 和 <code>!=</code> 都会对操作数进行强制转型，然后再比较相等性，转型规则如下：</p><ul><li>若一个操作数是布尔值，比较之前会将 <code>true</code> 转换为1，<code>false</code> 转换为0</li><li>若一个操作数是字符串，另一个操作数是数值，比较之前先将字符串转换为数值</li><li>若一个操作数是对象，另一个操作数不是，则调用 <code>valueOf()</code> 方法，用得到的基本类型值按照前面规则比较</li><li><code>null == undefined</code></li><li>比较之前不能将 null 和 undefined 转换成其他任何值</li><li><code>NaN != 任意值</code></li><li>若两个操作数都是对象，则比较它们是不是同一个对象，若两者均指向同一对象，则返回 true，否则为 false</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span><span class="comment">// true</span></span><br><span class="line"><span class="string">'NaN'</span> == <span class="literal">NaN</span><span class="comment">// false</span></span><br><span class="line"><span class="number">5</span> == <span class="literal">NaN</span><span class="comment">// false</span></span><br><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span><span class="comment">// false</span></span><br><span class="line"><span class="literal">NaN</span> != <span class="literal">NaN</span><span class="comment">// true</span></span><br><span class="line"><span class="literal">false</span> == <span class="number">0</span><span class="comment">// true</span></span><br><span class="line"><span class="literal">true</span> == <span class="number">1</span><span class="comment">// true</span></span><br><span class="line"><span class="literal">true</span> == <span class="number">2</span><span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="number">0</span><span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="number">0</span><span class="comment">// false</span></span><br><span class="line"><span class="string">'5'</span> == <span class="number">5</span><span class="comment">// true</span></span><br></pre></td></tr></table></figure><h5 id="全等和不全等"><a href="#全等和不全等" class="headerlink" title="全等和不全等"></a>全等和不全等</h5><p><code>===</code> 和 <code>!==</code> ，比较之前不转换操作数数值类型，若全等即表示两个操作数未进行转换就相等。</p><p>注 ：<code>null !== undefined</code></p><h4 id="条件操作符"><a href="#条件操作符" class="headerlink" title="条件操作符"></a>条件操作符</h4><p>也称之为三目运算符，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> max = ( num1 &gt; num2 ) ? num1 : num2</span><br></pre></td></tr></table></figure><h4 id="赋值操作符"><a href="#赋值操作符" class="headerlink" title="赋值操作符"></a>赋值操作符</h4><p><code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code> <code>&gt;&gt;&gt;=</code> </p><p>使用赋值操作符只能简化赋值操作，并不能带来性能提升</p><h4 id="逗号操作符"><a href="#逗号操作符" class="headerlink" title="逗号操作符"></a>逗号操作符</h4><p>逗号操作符 <code>,</code> 常用于一条语句中执行多个操作</p><h3 id="语句-1"><a href="#语句-1" class="headerlink" title="语句"></a>语句</h3><h4 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a><code>if</code> 语句</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">25</span>) &#123;</span><br><span class="line">    alert(<span class="string">"Greater than 25."</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    alert(<span class="string">"Less than 0."</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alert(<span class="string">"Between 0 and 25, inclusive."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="do-while-语句"><a href="#do-while-语句" class="headerlink" title="do-while 语句"></a><code>do-while</code> 语句</h4><p><code>do-while</code> 语句是一种后测试循环语句，只有循环体中代码执行后，才会测试出口条件。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    i += <span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">while</span> (i&lt;<span class="number">10</span>)</span><br><span class="line">    </span><br><span class="line"><span class="built_in">console</span>.log(i)<span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h4 id="while-语句"><a href="#while-语句" class="headerlink" title="while 语句"></a><code>while</code> 语句</h4><p><code>while</code> 语句属于前测试循环语句，在循环体内代码执行之前，会对出口条件求值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (i &lt; <span class="number">10</span>)&#123;</span><br><span class="line">    i += <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(i)<span class="comment">// 10</span></span><br></pre></td></tr></table></figure><h4 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a><code>for</code> 语句</h4><p><code>for</code> 语句是前测试循环语句。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> count = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; count; i++)&#123;</span><br><span class="line">2alert(i); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="for-in-语句"><a href="#for-in-语句" class="headerlink" title="for-in 语句"></a><code>for-in</code> 语句</h4><p><code>for-in</code> 语句可以用来枚举对象的属性，若迭代对象变量为 null 或 undefined，则不再执行循环体。</p><h4 id="label-语句与-break-、continue-语句"><a href="#label-语句与-break-、continue-语句" class="headerlink" title="label 语句与 break 、continue 语句"></a><code>label</code> 语句与 <code>break</code> 、<code>continue</code> 语句</h4><p><code>label</code> 语句可以在代码中添加标签，一般可以由 <code>break</code> 或 <code>continue</code> 语句引用在 <code>for</code> 语句等循环语句中配合使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">outermost:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line">            <span class="comment">// 结束当前的两个 for 循环，退出到最外层执行 console </span></span><br><span class="line">            <span class="keyword">break</span> outermost; </span><br><span class="line">        &#125;</span><br><span class="line">        num++; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num);    <span class="comment">//55</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span>;</span><br><span class="line">outermost:</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j=<span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span> &amp;&amp; j == <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="comment">// 不再执行 continue 下方代码，跳出当前循环，继续执行外层循环</span></span><br><span class="line">            <span class="keyword">continue</span> outermost;</span><br><span class="line">        &#125;</span><br><span class="line">        num++; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(num);    <span class="comment">//95</span></span><br></pre></td></tr></table></figure><h4 id="with-语句"><a href="#with-语句" class="headerlink" title="with 语句"></a><code>with</code> 语句</h4><p><code>with</code> 语句的作用是将代码的作用域设定到一个特定的对象中。定义 <code>with</code> 语句的目的主要是为了简化多次编写同一个对象的工作，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> qs = location.search.substring(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> hostName = location.hostname;</span><br><span class="line"><span class="keyword">let</span> url = location.href;</span><br><span class="line"><span class="comment">// 使用 with 语句</span></span><br><span class="line"><span class="keyword">with</span>(location)&#123;</span><br><span class="line">    <span class="keyword">let</span> qs = search.substring(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> hostName = hostname</span><br><span class="line">    <span class="keyword">let</span> url = href</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：严格模式下不允许使用 <code>with</code> 语句，另外大量使用 <code>with</code> 语句会导致性能下降，不建议使用 <code>with</code> 语句</p></blockquote><h4 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a><code>switch</code> 语句</h4><p><code>switch</code> 语句与 <code>if</code> 语句关系最密切。在 <code>switch</code> 语句中，如果省略 <code>break</code>关键字，<code>name</code> 就会在执行完当前 <code>case</code> 后，继续执行下一个 <code>case</code>，而 <code>default</code> 关键字则用于在表达式不匹配前面任何一种情况时执行之后代码（相当于一个 <code>else</code> 语句）。</p><blockquote><p>注意：<code>switch</code> 语句在比较值时使用的是全等操作符，因此不会发生类型转换</p></blockquote><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>ECMAScript 中函数使用 <code>function</code> 关键字来声明，后面跟一组参数及函数体。</p><p>函数定义时不必指定是否返回值，任何函数在任何时候都可以通过 <code>return</code> 实现返回值，另外，<code>return</code> 语句后的代码不会被执行。当 <code>return</code> 后不带任何返回值时，函数在停止执行后返回 <code>undefined</code> 值，一般用于需要提前停止函数执行又不需要返回值的情况下。</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>函数的参数的个数是由调用函数时传入函数中的参数，即实际参数决定的，而非定义函数时的命名参数，即形式参数决定。</p><p>在函数体内部可以通过 <code>arguments</code> 对象来访问参数数组，从而获取传递给函数的每一个参数。而 <code>arguments</code> 对象是一个类数组对象，因此可以使用方括号语法 <code>arguments[0]</code> 访问其第一个元素，往后依次类推。另外，可以使用 <code>length</code> 属性可以确定传递到该函数的有多少个参数。</p><p>若函数定义时未定义形参，也可以在函数体内部使用 <code>arguments</code> 访问到传入函数的参数，此外 <code>arguments</code> 对象也可以与形参一起使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAdd</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">arguments</span>.length == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(num1 + <span class="number">10</span>)</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">arguments</span>.length == <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="comment">// 此处 arguments[0] 相当于形参 num1</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>] + num2)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>非严格模式下，<code>arguments</code> 的值会与对应命名参数的值保持同步，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAdd</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">1</span>] = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>] + num2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 若实参长度大于1，每次执行该函数时都会将第二个参数的值修改为10，由于 arguments 对象中的值会自动反映到对应的命名参数，因此修改 arguments[1] 也就修改了 num2。</span></span><br><span class="line"><span class="comment">// 若实参长度为1或0，则 arguments[1] 设置的值不会反映到 num2 中，因为 arguments 长度由实参长度决定，而非形参</span></span><br><span class="line"><span class="comment">// 注意：arguments[1] 与 num2 的内存空间并不相同，而是互相独立的。</span></span><br></pre></td></tr></table></figure><p>若形参长度大于实参长度，则没有传递值的形参会被自动赋值 <code>undefined</code>。</p><p>严格模式下，重写 <code>arguments</code> 值会导致语法错误。</p><h4 id="没有重载"><a href="#没有重载" class="headerlink" title="没有重载"></a>没有重载</h4><p>ECMAScript 函数不能像传统意义上那样实现重载。若定义两个名字相同的函数，则后定义的函数会将先定义的函数覆盖，最终只有后定义的函数生效，不过可以通过检查传入函数中参数的类型和长度分别做处理来模拟重载</p><h3 id="小结-2"><a href="#小结-2" class="headerlink" title="小结"></a>小结</h3><ul><li><p>基本数据类型：<code>Undefined</code>、 <code>Null</code>、 <code>Boolean</code>、 <code>Number</code>、 <code>String</code></p></li><li><p><code>Number</code> 类型可以用于表示所有数值</p></li><li><p>复杂数据类型：<code>Objecket</code></p></li><li><p>严格模式为语言中易出错的地方加了限制</p></li><li><p>提供了很多与 C 及其他类 C 语言中相同的基本操作符，包括算术操作符、布尔操作符、关系操作符、相等操作符及赋值操作符等</p></li><li><p>从其他语言中借鉴了很多流控制语句，例如 if 语句、for 语句和 switch 语句等。 ECMAScript 中的函数与其他语言中的函数有诸多不同之处 </p></li><li><p>无需指定函数返回值，任何函数可以在任何时候返回任何值</p></li><li><p>未指定返回值得函数返回的是一个特殊的 undefined 值</p></li><li><p>可向函数中传递任意数量的参数，并可通过 <code>arguments</code> 对象来访问这些参数</p></li><li><p>没有函数签名的概念，因为函数参数是以一个包含零或多个值得数组形式传递的</p></li><li><p>由于不存在函数签名的特性，所以不能重载</p></li></ul><h2 id="变量、作用域和内存"><a href="#变量、作用域和内存" class="headerlink" title="变量、作用域和内存"></a>变量、作用域和内存</h2><p>JavaScript 由于不存在定义某个变量必须要保存何种数据类型值的规则，变量的值及其数据类型可以在脚本的生命周期内改变。</p><h3 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h3><p>变量可能包含两种不同数据类型的值：基本类型值和引用类型值。</p><p><strong>基本类型值</strong>指的是简单数据段：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code> 和 <code>String</code>， 这五种基本数据类型是按值访问的，因此可以操作保存在变量中的实际的值。</p><p><strong>引用类型值</strong>指的是可能由多个值构成的对象：<code>Object</code> ，<code>Function</code>， 引用类型的值是保存在内存中的对象。</p><p>将一个值赋给变量时，解析器必须确定这个值是基本类型值还是引用类型值。</p><p><code>JavaScript</code> 不允许直接访问内存中位置，因此不能直接操作对象的内存空间。</p><p>操作对象的本质是在操作对象的引用而非实际的对象。当复制保存对象的某个变量时，操作的是对象的内存地址的引用。为对象添加属性时，操作的是实际的对象。</p><h4 id="动态的属性"><a href="#动态的属性" class="headerlink" title="动态的属性"></a>动态的属性</h4><p>定义基本类型值和引用类型值得方式是类似的：创建一个变量并为该变量赋值。但是，当这个值保存到变量中以后，对不同类型值可执行的操作则大相径庭：</p><blockquote><p>对于引用类型的值，可以添加属性和方法，也可以改变和删除其属性和方法。</p><p>但对于基本类型的值，不能添加属性，尽管这样做不会导致任何错误。</p></blockquote><h4 id="复制变量值"><a href="#复制变量值" class="headerlink" title="复制变量值"></a>复制变量值</h4><p>在从一个变量向另一个变量复制基本类型值和引用类型值时，也存在不同。</p><p>若复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到新变量分配的位置上。其中新变量和被复制的变量的内存地址是相互独立的，两者的值可以参与任何操作而不会相互影响。</p><p><img src="https://qiniu.wplll.com/image/blog/%E5%A4%8D%E5%88%B6%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B.png" alt="复制基本类型" title="复制基本类型"></p><p>若复制引用类型，也会将存储在变量对象中的值复制一份到新变量分配的空间中。与基本类型不同的是，复制的值得副本实际是一个指针，指向存储在堆栈中的对象的内存地址，因此两个变量实际上都引用同一个对象，两者均指向内存空间的同一个值。若改变一个变量，就会改变实际的引用对象，由此导致另一个变量随之改变。</p><p><img src="https://qiniu.wplll.com/image/blog/%E5%A4%8D%E5%88%B6%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B.png" alt="复制引用类型" title="复制引用类型"></p><h4 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h4><p>ECMAScript 中所有函数的参数都是按值传递的，也就是说将函数外部的值复制给函数内部的参数，就是把值从一个变量复制到另一个变量。</p><p>向参数传递基本类型的值时，被传递值会复制给一个局部变量（形参），实参与形参之间，对其中一个进行操作不会影响另外一个。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addTen</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">    num += <span class="number">10</span></span><br><span class="line">2<span class="keyword">return</span> num</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> count = <span class="number">20</span></span><br><span class="line"><span class="keyword">var</span> result = addTen(count) </span><br><span class="line"><span class="built_in">console</span>.log(count)<span class="comment">//20，没有变化 </span></span><br><span class="line"><span class="built_in">console</span>.log(result)<span class="comment">//30</span></span><br></pre></td></tr></table></figure><p>而向参数传递引用类型值时，会把这个引用类型的值的内存地址复制给一个局部变量（形参），因此这个局部变量的变化会体现在函数的外部。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    obj.name = <span class="string">"Nicholas"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">setName(person)</span><br><span class="line"><span class="built_in">console</span>.log(person.name)<span class="comment">//"Nicholas"</span></span><br></pre></td></tr></table></figure><p>向参数传递对象时，实际传递的是该对象对应的内存地址的引用，本质还是值的传递。若在函数内部改变形参的值，改为其他对象的引用，此时再改变形参的属性值，则不会影响实参，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setName</span>(<span class="params">obj</span>)</span>&#123;</span><br><span class="line">    obj.name = <span class="string">'dong'</span></span><br><span class="line">    obj = <span class="keyword">new</span> <span class="built_in">Object</span>()<span class="comment">// 此时该形参已与实参无关</span></span><br><span class="line">    obj.name = <span class="string">'xiao'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;&#125;</span><br><span class="line">setName(person)</span><br><span class="line"><span class="built_in">console</span>.log(person.name)<span class="comment">// dong</span></span><br></pre></td></tr></table></figure><h4 id="检测类型"><a href="#检测类型" class="headerlink" title="检测类型"></a>检测类型</h4><p>检测基本数据类型用 <code>typeof</code> ，若一个变量的值是一个对象或 <code>null</code>，返回值为 <code>object</code> 。</p><p>检测引用类型则用 <code>instanceof</code> 。所有引用类型的值均为 Object 实例，因此使用 <code>instanceof</code> 操作符检测基本类型的值，返回值始终为 false，若检测引用类型和 Object 构造函数时，始终返回 true。</p><h3 id="执行环境及作用域"><a href="#执行环境及作用域" class="headerlink" title="执行环境及作用域"></a>执行环境及作用域</h3><p>执行环境，即执行上下文，定义了变量或者函数有权访问的其他数据，决定了它们各自的行为。</p><p>每个执行环境都有一个与之关联的<strong>变量对象</strong>，环境中定义的变量和函数都保存在这个对象中。这个对象我们编写的代码无法访问，但解析器会在处理数据时在后台使用它。</p><p>全局执行环境是最外层的一个执行环境。</p><p>在 Web 浏览器中，全局执行环境被认为是 <code>Window</code> 对象。因此所有全局变量和函数都是作为 window 对象的属性和方法创建的。当某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁。</p><p>全局执行环境会直至应用程序退出（如关闭网页或浏览器）时才会被销毁。</p><p>每个函数都有自己的执行环境，当执行流进入一个函数时，函数环境被推入一个环境栈中，函数执行后，栈将其环境弹出，将控制权返回给之前的执行环境。</p><p>当代码在一个环境中执行时，会创建变量对象的一个<strong>作用域链</strong>，用以保证对执行环境有权访问的所有变量和函数的有序访问。</p><p>作用域链的前端始终是当前执行代码所在环境的变量对象。若该环境是一个函数，则将其活动对象作为变量对象。活动对象在最开始时只包含一个变量，即 <code>arguments</code> 对象（全局环境中不存在）。作用域链中的下一个变量对象来自其外部环境，而再下一个变量对象则来自下一个包含环境。这样一直延续到全局执行环境：全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p><p>标识符解析是沿着作用域链一级一级的从作用域链的前段开始逐渐向后回溯搜索标识符的过程，直至找到标识符。若找不到标识符，通常会导致错误发生。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">"blue"</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> anotherColor = <span class="string">"red"</span> </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swpColors</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> tempColor = anotherColor</span><br><span class="line">        anotherColor = color</span><br><span class="line">        color = tempColor</span><br><span class="line">        <span class="comment">// 这里处于作用域链的最前端，可以顺着作用域链访问到该作用域链上其他所有的变量对象，即 color，anotherColor 和 tempColor</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里可以访问 color 和 anotherColor，但不能访问 tempColor</span></span><br><span class="line">    swapColors()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里只能访问 color</span></span><br><span class="line">changeColor()</span><br></pre></td></tr></table></figure><blockquote><p>以上代码涉及到三个执行环境：<code>全局环境</code>，<code>changeColor()</code> 和 <code>swapColors()</code> 的局部环境。</p></blockquote><p><img src="https://qiniu.wplll.com/image/blog/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE.png" alt="作用域链" title="作用域链"></p><p>内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量核函数。这些环境之间的联系是线性，有次序的。每个环境都可以向上搜索作用域链，以查询变量和函数名。但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。</p><h4 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h4><p>当执行流进入 <code>try-catch</code> 语句的 <code>catch</code> 块或者 <code>with</code> 语句时，将会延长作用域链。</p><p>对于 <code>catch</code> 语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。</p><p>对于 <code>with</code> 语句来说，会将指定的对象添加到作用域链中。</p><h4 id="没有块级作用域"><a href="#没有块级作用域" class="headerlink" title="没有块级作用域"></a>没有块级作用域</h4><p><code>if</code> 语句和 <code>for</code> 语句中声明的变量会将变量添加到语句外的执行环境中。</p><p>使用 <code>var</code> 声明的变量会自动添加到最接近的环境中，函数内部即为函数的局部环境，<code>with</code> 语句中即为函数环境。</p><p>若初始化变量时没使用 <code>var</code> 声明，该变量会被添加到全局环境中。</p><p>当在某个环境中查询一个变量标识符时，会从作用域链前端开始，向外层作用域逐层查询。若查到，则停止查询，此时即使父环境中有同名标识符，也会优先使用当前环境中的标识符。若未查到，则继续沿作用域链向上层搜索，直至全局对象，若仍未找到，则该该变量未声明。</p><h3 id="垃圾收集"><a href="#垃圾收集" class="headerlink" title="垃圾收集"></a>垃圾收集</h3><p>JavaScript 中常用的垃圾收集方式是<strong>标记清除</strong>。</p><blockquote><p>垃圾收集器运行时会将内存中的所有变量都加上标记</p><p>将在环境中的变量及被环境中变量引用的变量的标记去除</p><p>剩下的还存在标记的变量就是准备删除的变量</p><p>最后垃圾收集器会销毁带标记的值并收回它们所占的内存空间，完成内存清除</p></blockquote><p>还有一种垃圾收集方式是<strong>引用计数</strong>。</p><blockquote><p>引用计数含义是记录每个值被引用的次数。</p><p>当声明一个变量并将一个引用类型值赋给该变量时，这个值得引用次数就是 1。如果同一个值又被付给了另外一个变量，则该值的引用次数加 1。相反，如果包含对这个值引用的变量又取了另外一个值（即释放了对初始变量的引用），则这个值得引用次数减 1。当这个值的引用次数变为 0 时，回收其占用的内存空间。当垃圾收集器再次运行时会释放引用次数为 0 的值所占的内存空间。</p></blockquote><p>但是引用计数有一个严重缺陷，当对象 A 中包含一个指向对象 B 的指针，而对象 B 中也包含了一个指向对象 A 的引用，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">problem</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> objectA = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    <span class="keyword">var</span> objectB = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    objectA.someOtherObject = objectB</span><br><span class="line">    objectB.anotherObject = objectA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若采用标记清除，当 <code>problem</code> 函数执行完毕后，这两个对象离开了作用域，则释放其相对应的内存。但是若采用引用计数清除，这两个对象不会被清除，因为它们的引用次数不可能为0。</p><p>若要避免类似循环引用问题，则需要在不使用它们的时候手工断开它们之间的联系，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objectA.someOtherObject = <span class="literal">null</span></span><br><span class="line">objectB.anotherObject = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p><strong>解除引用</strong>：优化内存占用的最佳方式就是为执行中的代码只保存必要的数据，一旦数据不再有用，最好将其置 <code>null</code> 来释放其引用。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用。</p><h3 id="小结-3"><a href="#小结-3" class="headerlink" title="小结"></a>小结</h3><p><code>JavaScript</code> 变量可以用来保存<strong>基本类型值</strong>和<strong>引用类型值</strong>。</p><p><strong>基本类型值</strong>源于以下五种基本数据类型：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>Number</code> 和 <code>String</code>。</p><p>基本类型值和引用类型值具有以下特点：</p><ul><li>基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中</li><li>从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本</li><li>引用类型的值是对象，保存在堆内存中</li><li>包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针</li><li>从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象</li><li>确定一个值是哪种基本类型可以使用 typeof 操作符，而确定一个值是哪种引用类型可以使用 instanceof 操作符</li></ul><p>所有变量都存在于一个<strong>执行环境</strong>（即作用域）中，这个执行环境决定了变量的声明周期，及那一部分代码可以访问其中的变量。</p><ul><li>执行环境分为全局执行环境和函数执行环境</li><li>每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链</li><li>函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问局部环境中的任何数据</li><li>变量的执行环境有助于确定应该何时释放内存</li></ul><p>JavaScript 是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。</p><ul><li>离开作用域的值将被自动标记为可回收，因此在垃圾收集期间被删除</li><li><strong>标记清除</strong>是目前主流的垃圾收集算法，思想是给当前不使用的值加上标记，然后再回收其内存</li><li><strong>引用计数</strong>是另外一种垃圾收集算法，思想是跟踪记录所有值被引用的次数。</li><li>当代码中存在循环引用的现象时，<strong>引用计数</strong>算法会导致问题。</li><li>解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效的回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;blockquote class=&quot;blockquote-center&quot;&gt;&lt;p&gt;JavaScript 基础知识巩固 &lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="技术" scheme="http://wplll.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="传参" scheme="http://wplll.com/tags/%E4%BC%A0%E5%8F%82/"/>
    
      <category term="JavaScript" scheme="http://wplll.com/tags/JavaScript/"/>
    
      <category term="基础" scheme="http://wplll.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
